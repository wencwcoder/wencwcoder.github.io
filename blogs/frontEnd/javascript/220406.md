---
title: JavaScript实用知识
date: 2022-04-06
categories:
 - 前端
tags:
 - JavaScript
---

<!-- more -->



## 1. 杂记

### JavaScript 数组的常用方法

```javascript
// 增
push()、unshift()、splice()、concat()
// 删
pop()、shift()、splice()、slice()
// 改
splice()
// 查
indexOf()、includes()、find()
// 排序方法
reverse()、sort()
// 转换方法
join()
// 迭代方法（都不改变原数组）
some()、every()、forEach()、filter()、map()
// 构造函数
Array.from()、Array.of()、Array()
```



### JavaScript 字符串的常用方法

```javascript
// 增
+、${}、concat()
// 删
slice()、substr()、substring()
// 改
trim()、trimLeft()、trimRight()、repeat()、padStart()、padEnd()、toLowerCase()、 toUpperCase()
// 查
chatAt()、indexOf()、startWith()、includes()
// 转换方法
split()
// 模板匹配方法，针对正则表达式设计
match()、search()、replace()
```



### JavaScript 对象的常用方法

```javascript
// 合并
Object.assign()
// 遍历
键名：Object.keys()、键值：Object.values()、键值对：Object.entries()
// 原型
Object.setPrototypeOf()、Object.getPrototypeOf()
```



### JavaScript 函数的扩展

- 参数：`ES6 `允许为函数的参数设置默认值。
- 属性：length 属性 -- `length` 将返回没有指定默认值的参数个数（`rest` 参数也不会计入`length`属性；设置了默认值的参数不是尾参数，那么`length`属性也不再计入后面的参数了）；name 属性 -- 返回该函数的函数名。

```javascript
(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2
(function(...args) {}).length // 0
(function (a, b = 1, c) {}).length // 1
```



### == 和 === 的区别

- 等于操作符 ==：操作数相等，则会返回 `true`；存在隐式转换，在比较中会先进行**类型转换**，再确定操作数是否相等。
- 全等操作符 ===：只有两个操作数在不转换的前提下相等才返回 `true`，即类型相同，值也需相同。

```markdown
== 总结：
- 两个都为简单类型，字符串和布尔值都会转换成数值，再比较；
- 简单类型与引用类型比较，对象转化成其原始类型的值，再比较；
- 两个都为引用类型，则比较它们是否指向同一个对象；
- null 和 undefined 相等；
- 存在 NaN 则返回 false。
```



### 顶层对象

- 在浏览器环境指的是 `window` 对象，在 `Node` 指的是 `global` 对象。



### super 关键字

- `this `关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字 `super`，指向当前对象的原型对象。



### Set、Map 两种数据结构的理解

- `Set ` 是一种叫做集合的数据结构，`Map ` 是一种叫做字典的数据结构。
- 集合：是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合。
- 字典：是一些元素的集合。每个元素有一个称作 key 的域，不同元素的 key 各不相同。
- 集合与字典的区别：共同点：集合、字典都可以存储不重复的值；不同点：集合是以 **[值，值]** 的形式存储元素，字典是以 **[键，值]** 的形式存储。
- `Set ` 的实例关于增删改查的方法：add()、delete()、has()、clear()。
- `Map` 的实例关于增删改查有以下属性和操作方法：size 属性、set()、get()、has()、delete()、clear()。
- `WeakSet` 和 `WeakMap`：`WeackSet` 成员只能是引用类型；`WeakMap` 只接受对象作为键名（`null `除外）。



### Generator 函数

- Generator 函数：是 ES6 提供的一种异步编程解决方案，语法行为与传统函数（回调函数、Promise）完全不同。执行 `Generator` 函数会返回一个遍历器对象，可以依次遍历 `Generator` 函数内部的每一个状态。
- 形式上，`Generator` 函数是一个普通函数，但是有两个特征：`function` 关键字与函数名之间有一个星号；函数体内部使用 `yield` 表达式，定义不同的内部状态。
- `yield ` 表达式可以暂停函数执行，`next` 方法用于恢复函数执行，这使得 `Generator` 函数非常适合将异步任务同步化。

```javascript
function* helloWorldGenerator() {
  yield 'hello';
  yield 'world';
  return 'ending';
}

function* foo(x) {
  var y = 2 * (yield (x + 1));
  var z = yield (y / 3);
  return (x + y + z);
}
var a = foo(5);
a.next() // Object{value:6, done:false}
a.next() // Object{value:NaN, done:false}
a.next() // Object{value:NaN, done:true}
var b = foo(5);
b.next() // { value:6, done:false }
b.next(12) // { value:8, done:false }
b.next(13) // { value:42, done:true }
```



### Proxy

- `Proxy` 为构造函数，用来生成 `Proxy` 实例：`var proxy = new Proxy(target, handler)`。
- 参数：`target` 表示所要拦截的目标对象（任何类型的对象，包括原生数组，函数，甚至另一个代理）；`handler` 通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 `p` 的行为。
- Reflect：若需要在 `Proxy` 内部调用对象的默认行为，建议使用 `Reflect`，其是 `ES6` 中操作对象而提供的新  `API`。

```javascript
var person = {
  name: "张三"
};
var proxy = new Proxy(person, {
  get: function(target, propKey) {
    return Reflect.get(target, propKey)
  }
});
proxy.name // "张三"
```

- 如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则会报错。

```javascript
const target = Object.defineProperties({}, {
  foo: {
    value: 123,
    writable: false,
    configurable: false
  },
});
const handler = {
  get(target, propKey) {
    return 'abc';
  }
};
const proxy = new Proxy(target, handler);
proxy.foo
// TypeError: Invariant check failed
```

- 取消代理：`Proxy.revocable(target, handler)`。
- 使用场景：拦截和监视外部对对象的访问、降低函数或类的复杂度、在复杂操作前对操作进行校验或对所需资源进行管理。



### Module

- 模块（Module），是能够单独命名并独立地完成一定功能的程序语句的**集合（即程序代码和数据结构的集合体）**。
- 两个基本的特征：外部特征和内部特征。外部特征是指模块跟外部环境联系的接口（即其他模块或程序调用该模块的方式，包括有输入输出参数、引用的全局变量）和模块的功能；内部特征是指模块的内部环境具有的特点（即该模块的局部数据和程序代码）。
- 为什么需要模块化：代码抽象、代码封装、代码复用、依赖管理。
- 将 `JavaScript` 程序模块化的机制，例如：CommonJs (典型代表：node.js 早期)、AMD (典型代表：require.js)、CMD (典型代表：sea.js)。
- CommonJs：是一套 `Javascript` 模块规范，用于服务端。模块是同步加载的。
- AMD：`Asynchronous ModuleDefinition`（AMD），异步模块定义，采用异步方式加载模块。所有依赖模块的语句，都定义在一个回调函数中，等到模块加载完成之后，这个回调函数才会运行。
- ES6 在语言标准的层面上，实现了 `Module`，即模块功能，完全可以取代 `CommonJS` 和 `AMD` 规范，成为浏览器和服务器通用的模块解决方案。`CommonJS` 和 `AMD` 模块，都只能在运行时确定这些东西，`ES6` 可以在编译时就完成模块加载。



## 2. 实用库



