---
title: 重学前端
date: 2021-06-22
categories:
 - 随笔
tags:
 - 极客时间
---

<!-- more -->



## 1. 开篇词 + 学习路线 + 架构图

### 开篇词 | 从今天起，重新理解前端

- keywords：软件工程体系；UI 架构；浏览器的工作原理；前端工程化；程序员通用的编程能力和架构能力。

- 关于前端工程师成长，需要两个视角。一是立足标准，系统性总结和整理前端知识，建立自己的认知和方法论；二是放眼团队，从业务和工程角度思考前端团队的价值和发展需要。只有这样做，才能够持续发展，在高速发展的技术和工程浪潮中稳稳立足。



### 明确你的前端学习路线与方法

- keywords：前端的基础知识；前端学习方法；知识架构；前端技术背后的核心思想；**基于原型的语言**。

- 前端学习方法：【1】建立知识架构；【2】追本溯源。


- 文法  -->  语义  -->  运行时；对于任何计算机语言来说，必定是“用规定的文法，去表达特定语义，最终操作运行时的”一个过程。


- 文法：词法、语法；语义；运行时：类型、执行过程。（词法中有各种直接量、关键字、运算符，语法和语义则是表达式、语句、函数、对象、模块，类型则包含了对象、数字、字符串等……）


- **程序 = 算法 + 数据结构**，对运行时来说，类型就是数据结构，执行过程就是算法。
- JavaScript 之父 Brendan Eich 曾经在 Wikipedia 的讨论页上解释 JavaScript 最初想设计一个带有 prototype 的 scheme，结果受到管理层命令把它弄成像 Java 的样子。（为什么javascript最初设计成 prototype-based而不是class-based，[链接](https://www.zhihu.com/question/27689001)）

::: tip
前端基础 -> 函数库 -> 组件库 -> 框架 -> 工程化。
:::



### 前端知识架构图

- keywords：MDN。

- 前端的知识在总体上分成基础部分和实践部分，基础部分包含了 JavaScript 语言（模块一）、CSS 和 HTML（模块二）以及浏览器的实现原理和 API（模块三），这三个模块涵盖了一个前端工程师所需要掌握的全部知识。


#### JavaScript

![img](https://static001.geekbang.org/resource/image/6a/9b/6aec0a09381a2f74014ec604ef99c19b.png)

在 JavaScript 的模块中，首先我们可以把语言按照文法、语义和运行时来拆分，这符合**编程语言的一般规律：用一定的词法和语法，表达一定语义，从而操作运行时**。

接下来，我们又按照程序的一般规律，把运行时分为数据结构和算法部分：数据结构包含类型和实例（JavaScript 的类型系统就是它的 7 种基本类型和 7 种语言类型，实例就是它的内置对象部分）。所谓的算法，就是 JavaScript 的执行过程。

#### HTML 和 CSS

![img](https://static001.geekbang.org/resource/image/41/62/4153891927afac7f4c21ccf6a141f062.png)

在 HTML 的部分，基于这样的分类，我把标签元素分成下面几种：

文档元信息：通常是出现在 head 标签中的元素，包含了描述文档自身的一些信息；

语义相关：扩展了纯文本，表达文章结构、不同语言要素的标签；

链接：提供到文档内和文档外的链接；

替换型标签：引入声音、图片、视频等外部元素替换自身的一类标签；

表单：用于填写和提交信息的一类标签；

表格：表头、表尾、单元格等表格的结构。

除了标签之外，我们还应该把 HTML 当作一门语言来了解下，当然，标记语言跟编程语言不太一样，没有编程语言那么严谨，所以，我们会简要介绍 HTML 的语法和几个重要的语言机制：实体、命名空间。最后我们会介绍下 HTML 的补充标准：ARIA，它是 HTML 的扩展，在可访问性领域，它有至关重要的作用。

#### 浏览器的实现原理和 API

![img](https://static001.geekbang.org/resource/image/cb/cb/cbb6d198ccfb95af4906eeb0581333cb.png)

浏览器部分我们会先介绍下浏览器的实现原理，这是我们深入理解 API 的基础。会从一般的浏览器设计出发，按照解析、构建 DOM 树、计算 CSS、渲染、合成和绘制的流程来讲解浏览器的工作原理。

#### 前端工程实践

![img](https://static001.geekbang.org/resource/image/45/ce/4568011037a5591402c4ba1547ba0dce.jpg)

性能：对任何一个前端团队而言，性能是它价值的核心指标，从早年“重构”的实践开始，前端有通过性能证明自己价值的传统。但是性能并非细节的堆砌，也不是默默做优化，所以，我会从团队的角度来跟你一起探讨性能的方法论和技术体系。

工具链：探讨企业中工具链的建设思路。对一个高效又合作良好的前端团队来说，一致性的工具链是不可或缺的保障，作为开发阶段的入口，工具链又可以和性能、发布、持续集成等系统链接到一起，成为团队技术管理的基础。

持续集成：持续集成并非一个新概念，但是过去持续集成概念和理论都主要针对软件开发，而对前端来说，持续集成是一个新的课题（当然对持续集成来说，前端也是一个新课题），比如 daily build 就完全不适用前端，前端代码必须是线上实时可用的。

搭建系统：前端工作往往多而繁杂，针对高重复性、可模块化的业务需求，传统的人工开发不再适用，搭建系统是大部分大型前端团队的选择。

架构与基础库：软件架构师主要解决功能复杂性的问题，服务端架构师主要解决高流量问题，而前端是页面间天然解耦，分散在用户端运行的系统，但是前端架构也有自己要解决的问题。前端需求量大、专业人才稀缺，更因为前端本身运行在浏览器中，有大量兼容工作要做。所以前端架构的主要职责是兼容性、复用和能力扩展。

![img](https://static001.geekbang.org/resource/image/d1/a8/d1cb4040d91207075e0591abffe1b9a8.jpg)

## 2. 模块一：JavaScript

### JavaScript类型：关于类型，有哪些你不知道的细节

- 类型：JavaScript 语言的每一个值都属于某一种数据类型。JavaScript 语言规定了 7 种语言类型。语言类型广泛用于变量、函数参数、表达式、函数返回值等场合。根据最新的语言标准，这 7 种语言类型是：Undefined；Null；Boolean；String；Number；Symbol；Object。


#### Undefined、Null

- 为什么有的编程规范要求用 void 0 代替 undefined：Undefined 类型表示未定义，它的类型只有一个值，就是 undefined。任何变量在赋值前是 Undefined 类型、值为 undefined，一般我们可以用全局变量 undefined（就是名为 undefined 的这个变量）来表达这个值，或者 void 运算来把任意一个表达式变成 undefined 值。但是呢，因为 JavaScript 的代码 undefined 是一个**变量**，而并非是一个**关键字**，这是 JavaScript 语言公认的设计失误之一，所以，我们为了避免无意中被篡改，我建议使用 void 0 来获取 undefined 值。


- Undefined 跟 Null 有一定的表意差别，Null 表示的是：“定义了但是为空”。所以，在实际编程时，我们一般**不会把变量赋值为 undefined**，这样可以保证所有值为 undefined 的变量，都是从未赋值的自然状态。


- Null 类型也只有一个值，就是 null，它的语义表示空值，与 undefined 不同，null 是 JavaScript 关键字，所以在任何代码中，你都可以放心用 null 关键字来获取 null 值。


#### Boolean

- Boolean 类型有两个值， true 和 false，它用于表示逻辑意义上的真和假，同样有关键字 true 和 false 来表示两个值。


#### String

- 字符串是否有最大长度？


- String 用于表示文本数据。String 有最大长度是 2^53 - 1，这在一般开发中都是够用的，但是有趣的是，这个所谓最大长度，并不完全是你理解中的字符数。


- 因为 String 的意义并非“字符串”，而是**字符串的 UTF16 编码**，我们字符串的操作 charAt、charCodeAt、length 等方法针对的都是 UTF16 编码。所以，字符串的最大长度，实际上是受**字符串的编码长度**影响的。


- JavaScript 中的字符串是永远无法变更的，一旦字符串构造出来，无法用任何方式改变字符串的内容，所以字符串具有值类型的特征。


- JavaScript 字符串把每个 UTF16 单元当作一个字符来处理，所以处理非 BMP（超出 U+0000 - U+FFFF 范围）的字符时，你应该格外小心。【0-65536（U+0000 - U+FFFF）的码点被称为基本字符区域（BMP）】


- JavaScript 这个设计继承自 Java，最新标准中是这样解释的，这样设计是为了“性能和尽可能实现起来简单”。因为现实中很少用到 BMP 之外的字符。


#### Number

- Number 类型表示我们通常意义上的“数字”。这个数字大致对应数学中的有理数，当然，在计算机中，我们有一定的精度限制。JavaScript 中的 Number 类型有 18437736874454810627(即 2^64-2^53+3) 个值。
- JavaScript 中的 Number 类型基本符合 IEEE 754-2008 规定的双精度浮点数规则，但是 JavaScript 为了表达几个额外的语言场景（比如不让除以 0 出错，而引入了无穷大的概念），规定了几个例外情况：NaN，占用了 9007199254740990，这原本是符合 IEEE 规则的数字；Infinity，无穷大；-Infinity，负无穷大。

- 另外，值得注意的是，JavaScript 中有 +0 和 -0，在加法类运算中它们没有区别，但是除法的场合则需要特别留意区分，“忘记检测除以 -0，而得到负无穷大”的情况经常会导致错误，而区分 +0 和 -0 的方式，正是检测 1/x 是 Infinity 还是 -Infinity。


- 根据双精度浮点数的定义，Number 类型中有效的整数范围是 -0x1fffffffffffff 至 0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数。【支持数值范围是：-2^53~2^53，即：- 9007199254740991(0x1FFFFFFFFFFFFF)～9007199254740991(0x1FFFFFFFFFFFFF)。】


- 同样根据浮点数的定义，非整数的 Number 类型无法用 ==（=== 也不行） 来比较，一段著名的代码，为什么在 JavaScript 中，0.1+0.2 不能 =0.3：【非整形的数字有精度要求，所以不相等；事实上不是无法比较，浮点数是可以比较的，不过由于精度的问题可能导致一些在计算中理所当然的结果并不会出现，所以 JavaScript 才会规定浮点数不可以进行比较】


- Number 类型运算都要想将其转化为二进制，将二进制运算，运算的结果再转化为十进制，因为 Number 是64位双精度，小数部分只有52位，但0.1转化成为二进制是无限循环的，所以四舍五入了，这里就发生了精度丢失，0.1的二进制和0.2的二进制相加需要保留有效数字，所以又发生了精度丢失，所以结果为0.300000000000004，所以为false，而0.2+0.3恰好两个转化成为二进制和相加的过程都不会发生精度丢失，所以为true。


```javascript
console.log( 0.1 + 0.2 == 0.3);
```

- 这里输出的结果是 false，说明两边不相等的，这是浮点运算的特点，也是很多同学疑惑的来源，浮点数运算的精度问题导致等式左右的结果并不是严格相等，而是相差了个微小的值。


- 所以实际上，这里错误的不是结论，而是比较的方法，正确的比较方法是使用 JavaScript 提供的最小精度值；用最小精度比较，防止浮点数运算导致的精度问题造成结果错误：（检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法。这段代码结果就是 true 了）


```javascript
console.log( Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON);
```

#### Symbol

- Symbol 是 ES6 中引入的新类型，它是一切非字符串的对象 key 的集合，在 ES6 规范中，整个**对象系统**被用 Symbol 重塑。Symbol 跟对象系统的关系，在后面的文章中会详细叙述。在这里我们只介绍 Symbol 类型本身：它有哪些部分，它表示什么意思，以及如何创建 Symbol 类型。


- Symbol 可以具有字符串类型的描述，但是即使描述相同，Symbol 也不相等。


- 我们创建 Symbol 的方式是使用全局的 Symbol 函数。例如：


```javascript
var mySymbol = Symbol("my symbol");
```

- 一些标准中提到的 Symbol，可以在全局的 Symbol 函数的属性中找到。例如，我们可以使用 Symbol.iterator 来自定义 for…of 在对象上的行为：


```javascript
var o = new Object

o[Symbol.iterator] = function() {
    var v = 0
    return {
        next: function() {
            return { value: v++, done: v > 10 }
        }
    }        
};

for(var v of o) 
    console.log(v); // 0 1 2 3 ... 9
```

- 代码中我们定义了 iterator 之后，用 for(var v of o) 就可以调用这个函数，然后我们可以根据函数的行为，产生一个 for…of 的行为。这里我们给对象 o 添加了 Symbol.iterator 属性，并且按照迭代器的要求定义了一个 0 到 10 的迭代器，之后我们就可以在 for of 中愉快地使用这个 o 对象啦。


- 这些标准中被称为“众所周知”的 Symbol，也构成了语言的一类接口形式。它们允许编写与语言结合更紧密的 API。


#### Object

- Object 是 JavaScript 中最复杂的类型，也是 JavaScript 的核心机制之一。Object 表示对象的意思，它是一切有形和无形物体的总称。


- 为什么给对象添加的方法能用在基本类型上？


- 在 JavaScript 中，对象的定义是“属性的集合”。属性分为**数据属性**和**访问器属性**，二者都是 key-value 结构，key 可以是字符串或者 Symbol 类型。关于对象的机制，后面会有单独的一篇来讲述，这里我重点从类型的角度来介绍对象类型。提到对象，我们必须要提到一个概念：类。


- 因为 C++ 和 Java 的成功，在这两门语言中，每个类都是一个类型，二者几乎等同，以至于很多人常常会把 JavaScript 的“类”与类型混淆。事实上，JavaScript 中的“类”仅仅是运行时对象的一个私有属性，而 JavaScript 中是无法自定义类型的。


- JavaScript 中的几个基本类型，都在对象类型中有一个“亲戚”。它们是：Number；String；Boolean；Symbol。所以，我们必须认识到 3 与 new Number(3) 是完全不同的值，它们一个是 Number 类型， 一个是对象类型。
- Number、String 和 Boolean，三个构造器是两用的，当跟 new 搭配时，它们产生对象，当直接调用时，它们表示强制类型转换。Symbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。

- JavaScript 语言设计上试图模糊对象和基本类型之间的关系，我们日常代码可以把对象的方法在基本类型上使用，比如：


```javascript
console.log("abc".charAt(0)); // a
```

- 甚至我们在原型上添加方法，都可以应用于基本类型，比如以下代码，在 Symbol 原型上添加了 hello 方法，在任何 Symbol 类型变量都可以调用。


```javascript
Symbol.prototype.hello = () => console.log("hello");

var a = Symbol("a");
console.log(typeof a); //symbol，a并非对象
a.hello(); //hello，有效
```

- 所以前面的问题【为什么给对象添加的方法能用在基本类型上】，答案就是  . 运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。


#### 类型转换

- 介绍一个**现象**：类型转换。


- 因为 JavaScript 是弱类型语言，所以类型转换发生非常频繁，大部分我们熟悉的运算都会先进行类型转换。大部分类型转换符合人类的直觉，但是如果我们不去理解类型转换的严格定义，很容易造成一些代码中的判断失误。其中最为臭名昭著的是 JavaScript 中的“ == ”运算，因为试图实现跨类型的比较，它的规则复杂到几乎没人可以记住。这里我们当然也不打算讲解 == 的规则，它属于设计失误，并非语言中有价值的部分，很多实践中推荐**禁止使用“ ==”**，而要求程序员进行显式地类型转换后，用 === 比较。【现在的实践中，项目基本上使用 eslint 配置一些检测规则，来规避 == 比较】


- 其它运算，如加减乘除大于小于，也都会涉及类型转换。幸好的是，实际上大部分类型转换规则是非常简单的，如下表所示：


![img](https://static001.geekbang.org/resource/image/71/20/71bafbd2404dc3ffa5ccf5d0ba077720.jpg)

- 在这个里面，较为复杂的部分是 Number 和 String 之间的转换，以及对象跟基本类型之间的转换。我们分别来看一看这几种转换的规则。


- StringToNumber

  字符串到数字的类型转换，存在一个语法结构，类型转换支持十进制、二进制、八进制和十六进制，比如：30；0b111；0o13；0xFF。

  此外，JavaScript 支持的字符串语法还包括正负号科学计数法，可以使用大写或者小写的 e 来表示：1e3；-1e-2。

  需要注意的是，parseInt 和 parseFloat 并不使用这个转换，所以支持的语法跟这里不尽相同。

  在不传入第二个参数的情况下，parseInt 只支持 16 进制前缀“0x”，而且会忽略非数字字符，也不支持科学计数法。

  在一些古老的浏览器环境中，parseInt 还支持 0 开头的数字作为 8 进制前缀，这是很多错误的来源。所以在任何环境下，都建议传入 parseInt 的第二个参数，而 parseFloat 则直接把原字符串作为十进制来解析，它不会引入任何的其他进制。

  多数情况下，`Number` 是比 `parseInt` 和 `parseFloat` 更好的选择。【**Number**函数推荐使用】

- NumberToString

  在较小的范围内，数字到字符串的转换是完全符合你直觉的十进制表示。当 Number 绝对值较大或者较小时，字符串表示则是使用科学计数法表示的。这个算法细节繁多，我们从感性的角度认识，它其实就是保证了产生的字符串不会过长。

  `toString` 方法：不能转化 underfind 和 null；`String` 方法；`num +  ‘ ’` 。

- 装箱转换

  每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓**装箱转换，正是把基本类型转换为对应的对象**，它是类型转换中一种相当重要的种类。

  前文提到，全局的 Symbol 函数无法使用 new 来调用，但我们仍可以利用装箱机制来得到一个 Symbol 对象，我们可以利用一个函数的 call 方法来强迫产生装箱。我们定义一个函数，函数里面只有 return this，然后我们调用函数的 call 方法到一个 Symbol 类型的值上，这样就会产生一个 symbolObject。

  我们可以用 console.log 看一下这个东西的 typeof，它的值是 object，我们使用 symbolObject instanceof 可以看到，它是 Symbol 这个类的实例，我们找它的 constructor 也是等于 Symbol 的，所以我们无论从哪个角度看，它都是 Symbol 装箱过的对象：

  ```javascript
  var symbolObject = (function(){ return this; }).call(Symbol("a"));
  
  console.log(typeof symbolObject); // object
  console.log(symbolObject instanceof Symbol); // true
  console.log(symbolObject.constructor == Symbol); // true
  ```

  **装箱机制会频繁产生临时对象**，在一些对性能要求较高的场景下，我们应该尽量避免对基本类型做装箱转换。

  使用内置的 **Object 函数**，我们可以在 JavaScript 代码中显式调用装箱能力。

  ```javascript
  var symbolObject = Object(Symbol("a"));
  
  console.log(typeof symbolObject); //object
  console.log(symbolObject instanceof Symbol); //true
  console.log(symbolObject.constructor == Symbol); //true
  ```

  每一类装箱对象皆有私有的 **Class 属性**，这些属性可以用 Object.prototype.toString 获取：

  ```javascript
  var symbolObject = Object(Symbol("a"));
  
  console.log(Object.prototype.toString.call(symbolObject)); //[object Symbol]
  ```

  在 JavaScript 中，**没有任何方法可以更改私有的 Class 属性**，因此 `Object.prototype.toString` 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。

  但需要注意的是，call 本身会产生装箱操作，所以需要配合 typeof 来区分基本类型还是对象类型。

- 拆箱转换

  在 JavaScript 标准中，规定了 ToPrimitive 函数，它是**对象类型到基本类型的转换（即，拆箱转换）**。

  对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。

  拆箱转换会尝试调用 `valueOf` 和 `toString` 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 `TypeError`。

  ```javascript
  var o = {
  valueOf : () => {console.log("valueOf"); return {}},
  toString : () => {console.log("toString"); return {}}
  }
  
  o * 2
  // valueOf
  // toString
  // TypeError
  ```

  我们定义了一个对象 o，o 有 valueOf 和 toString 两个方法，这两个方法都返回一个对象，然后我们进行 o*2 这个运算的时候，你会看见先执行了 valueOf，接下来是 toString，最后抛出了一个 TypeError，这就说明了这个拆箱转换失败了。

  到 String 的拆箱转换会优先调用 toString。我们把刚才的运算从 o*2 换成 String(o)，那么你会看到调用顺序就变了。

  ```javascript
  var o = {
  valueOf : () => {console.log("valueOf"); return {}},
  toString : () => {console.log("toString"); return {}}
  }
  
  String(o)
  // toString
  // valueOf
  // TypeError
  ```

  在 ES6 之后，还允许对象通过显式指定 @@`toPrimitive` Symbol 来覆盖原有的行为。

  ```javascript
  var o = {
  valueOf : () => {console.log("valueOf"); return {}},
  toString : () => {console.log("toString"); return {}}
  }
  
  o[Symbol.toPrimitive] = () => {console.log("toPrimitive"); return "hello"}
  
  
  console.log(o + "")
  // toPrimitive
  // hello
  ```

#### 结语

在本篇文章中，我们介绍了 JavaScript 运行时的类型系统。

除了这七种**语言类型**，还有一些语言的实现者更关心的**规范类型**。

- List 和 Record： 用于描述函数传参过程。
- Set：主要用于解释字符集等。
- Completion Record：用于描述异常、跳出等语句执行过程。
- Reference：用于描述对象属性访问、delete 等。
- Property Descriptor：用于描述对象的属性。
- Lexical Environment 和 Environment Record：用于描述变量和作用域。
- Data Block：用于描述二进制数据。

有一个说法是：**程序 = 算法 + 数据结构**，运行时类型包含了所有 JavaScript 执行时所需要的数据结构的定义，所以我们要对它格外重视。

#### 补充

- 事实上，“类型”在 JavaScript 中是一个有争议的概念。一方面，标准中规定了运行时数据类型； 另一方面，JavaScript 语言中提供了 typeof 这样的运算，用来返回操作数的类型，但 typeof 的运算结果，与运行时类型的规定有很多不一致的地方。我们可以看下表来对照一下。


![img](https://static001.geekbang.org/resource/image/ec/6b/ec4299a73fb84c732efcd360fed6e16b.png)

- 在表格中，多数项是对应的，但是请注意 object——Null 和 function——Object 是特例，我们理解类型的时候需要特别注意这个区别。


- 从一般语言使用者的角度来看，毫无疑问，我们应该按照 typeof 的结果去理解语言的类型系统。但 JavaScript 之父本人也在多个场合表示过，typeof 的设计是有缺陷的，只是现在已经错过了修正它的时机。


- 不用原生的 number 和 parseInt，使用 JavaScript 实现从 string 到 number 的转换：


```javascript
function strToNum(a){
    let chars = a.split("").map(e => e.charCodeAt(0) - "0".charCodeAt(0));
    let n = 0;
    for(var char of chars){
        n *= 10;
      n += char;
    }
    return n;
}

strToNum("8947947")
```



### JavaScript对象：面向对象还是基于对象

- 在学习 JavaScript **面向对象**时，往往也会有疑惑：为什么 JavaScript（直到 ES6）有对象的概念，但是却没有像其他的语言那样，有类的概念呢；为什么在 JavaScript 对象里可以自由添加属性，而其他的语言却不能呢。实际上，基于对象和面向对象两个形容词都出现在了 JavaScript 标准的各个版本当中。
- JavaScript 标准对基于对象的定义，这个定义的具体内容是：**“语言和宿主的基础设施由对象来提供，并且 JavaScript 程序即是一系列互相通讯的对象集合”**。这里的意思根本不是表达弱化的面向对象的意思，反而是表达**对象对于语言的重要性**。
- 什么是面向对象：【1】因为翻译的原因，中文语境下我们很难理解“对象”的真正含义。事实上，Object（对象）在英文中，是**一切事物的总称**，这和面向对象编程的抽象思维有互通之处。中文的“对象”却没有这样的普适性，我们在学习编程的过程中，更多是把它当作一个专业名词来理解。但不论如何，我们应该认识到，对象并不是计算机领域凭空造出来的概念，它是顺着**人类思维模式**产生的一种抽象（于是面向对象编程也被认为是：更接近人类思维模式的一种编程范式）。【2】在《面向对象分析与设计》这本书中，Grady Booch 替我们做了总结，他认为，从人类的认知角度来说，对象应该是下列事物之一：一个可以触摸或者可以看见的东西；人的智力可以理解的东西；可以指导思考或行动（进行想象或施加动作）的东西。【3】有了对象的自然定义后，我们就可以描述编程语言中的对象了。在不同的编程语言中，设计者也**利用各种不同的语言特性来抽象描述对象**，最为成功的流派是**使用“类”的方式来描述对象**，这诞生了诸如 C++、Java 等流行的编程语言。而 JavaScript 早年却选择了一个更为冷门的方式：**原型**，这也是说它不合群的原因之一。【4】如果我们从运行时角度来谈论对象，就是在讨论 JavaScript 实际运行中的模型，这是由于任何代码执行都必定绕不开**运行时的对象模型**。不过，幸运的是，从运行时的角度看，可以不必受到这些“基于类的设施”的困扰，这是因为任何语言**运行时类的概念都是被弱化的**。
- 在人类思维模式下，对象究竟是什么：对象这一概念在人类的幼儿期形成，这远远早于我们编程逻辑中常用的值、过程等概念。在幼年期，我们总是先认识到某一个苹果能吃（这里的某一个苹果就是一个对象），继而认识到所有的苹果都可以吃（这里的所有苹果，就是一个类），再到后来我们才能意识到三个苹果和三个梨之间的联系，进而产生数字“3”（值）的概念。
- **类和原型是编程语言来抽象描述对象的两种不同方式。**
- JavaScript 对象的特征：不论我们使用什么样的编程语言，我们都先应该去理解对象的本质特征。总结来看，对象有如下几个特点，【1】**对象具有唯一标识性（内存地址）**：即使完全相同的两个对象，也并非同一个对象。【2】**对象有状态**：对象具有状态，同一对象可能处于不同状态之下。【3】**对象具有行为**：即对象的状态，可能因为它的行为产生变迁。
- 关于对象的第二个和第三个特征“状态和行为”，不同语言会使用不同的术语来抽象描述它们，比如 C++ 中称它们为“**成员变量**”和“**成员函数**”，Java 中则称它们为“**属性**”和“**方法**”。在 JavaScript 中，将状态和行为统一抽象为“**属性**”，考虑到 JavaScript 中将函数设计成一种特殊对象，所以 **JavaScript 中的状态和行为都能用属性来抽象**。
- **在实现了对象基本特征的基础上, 我认为，JavaScript 中对象独有的特色是：对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。**为了提高抽象能力，JavaScript 的属性被设计成比别的语言更加复杂的形式，它提供了**数据属性**和**访问器属性（getter/setter）**两类。
- JavaScript 对象的两类属性：**数据属性和访问器属性**。对 JavaScript 来说，属性并非只是简单的名称和值，JavaScript 用一组特征（attribute）来描述属性（property）。【1】数据属性，它比较接近于其它语言的属性概念，具有**四个特征**。value：就是属性的值；writable：决定属性能否被赋值；enumerable：决定 for in 能否枚举该属性；configurable：决定该属性能否被删除或者改变特征值。在大多数情况下，我们只关心数据属性的值即可。【2】访问器（getter/setter）属性，它也有**四个特征**。getter：函数或 undefined，在取属性值时被调用；setter：函数或 undefined，在设置属性值时被调用；enumerable：决定 for in 能否枚举该属性；configurable：决定该属性能否被删除或者改变特征值。访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。【3】我们通常用于定义属性的代码会产生数据属性，其中的 writable、enumerable、configurable 都默认为 true。我们可以使用内置函数 `getOwnPropertyDescriptor` 来查看。【4】如果我们要想改变属性的特征，或者定义访问器属性，我们可以使用 `Object.defineProperty`。

```javascript
var o = { a: 1 };
o.b = 2;
// a 和 b 皆为数据属性
Object.getOwnPropertyDescriptor(o,"a")
// {value: 1, writable: true, enumerable: true, configurable: true}
Object.getOwnPropertyDescriptor(o,"b")
// {value: 2, writable: true, enumerable: true, configurable: true}
```

```javascript
var o = { a: 1 };
Object.defineProperty(o, "b", {value: 2, writable: false, enumerable: false, configurable: true});
// a 和 b 都是数据属性，但特征值变化了
Object.getOwnPropertyDescriptor(o,"a");
// {value: 1, writable: true, enumerable: true, configurable: true}
Object.getOwnPropertyDescriptor(o,"b");
// {value: 2, writable: false, enumerable: false, configurable: true}
o.b = 3;
console.log(o.b); // 2，因为 writable 特征为 false，所以我们重新对 b 赋值，b 的值不会发生变化
```

- 在创建对象时，也可以使用 get 和 set 关键字来创建访问器属性。访问器属性跟数据属性不同，每次访问属性都会执行 getter 或者 setter 函数。这里我们的 getter 函数返回了 1，所以 o.a 每次都得到 1。**实际上 JavaScript 对象的运行时是一个“属性的集合”，属性以字符串或者 Symbol 为 key，以数据属性特征值或者访问器属性特征值为 value。**

```javascript
var o = { get a() { return 1 } };
console.log(o.a); // 1
// “a”是 key
// {writable:true,value:1,configurable:true,enumerable:true}是 value
```

- 对象是一个属性的索引结构（索引结构是一类常见的数据结构，我们可以把它理解为一个能够以比较快的速度用 key 来查找 value 的字典）。
- 由于 JavaScript 的对象设计跟目前主流基于类的面向对象差异非常大。可事实上，这样的对象系统设计虽然特别，但是 JavaScript 提供了完全运行时的对象系统，这使得它可以模仿多数面向对象编程范式（ JavaScript 中两种**面向对象编程的范式：基于类和基于原型**），所以它也是正统的**面向对象语言**。
- **JavaScript 对象的具体设计：具有高度动态性的属性集合。**



### JavaScript对象：我们真的需要模拟类吗

- JavaScript 本身就是面向对象的，只是它实现面向对象的方式和主流的流派不太一样，所以才让很多人产生了误会 -- JavaScript “模拟面向对象”，实际上做的事情就是 “模拟基于类的面向对象”。JavaScript 创始人 Brendan Eich 在 “原型运行时” 的基础上引入了 new、this 等语言特性，使之 “看起来语法更像 Java”。
- 什么是原型：原型是顺应人类自然思维的产物。中文中有个成语叫做 “照猫画虎”，这里的猫看起来就是虎的原型。【1】“基于类” 的编程提倡使用一个关注分类和类之间关系开发模型。先有类，再从类去实例化一个对象。【2】“基于原型” 的编程看起来更为提倡程序员去关注一系列对象实例的行为，而后才去关心如何将这些对象，划分到最近的使用方式相似的原型对象，而不是将它们分成类。【3】基于原型的面向对象系统通过 “复制” 的方式来创建新对象。原型系统的 “复制操作” 有两种实现思路：一个是并不真的去复制一个原型对象，而是使得新对象持有一个原型的引用；另一个是切实地复制对象，从此两个对象再无关联。JavaScript 显然选择了前一种方式。
- 所有对象都有 `__proto__`  属性, 只有函数才有 `prototype` 属性。
- JavaScript 的原型：原型系统可以说相当简单，用两条概括：如果所有对象都有私有字段 `[[prototype]]`，就是对象的原型；读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止。
- **但从 ES6 以来，JavaScript 提供了一系列内置函数，以便更为直接地访问操纵原型。**三个方法分别为：`Object.create` 根据指定的原型创建新对象，原型可以是 null；`Object.getPrototypeOf` 获得一个对象的原型；`Object.setPrototypeOf` 设置一个对象的原型。
- 早期版本中的类与原型：在早期版本的 JavaScript 中，“类” 的定义是一个`私有属性 [[class]]`，语言标准为内置类型诸如 Number、String、Date 等指定了 [[class]] 属性，以表示它们的类。语言使用者唯一可以访问 [[class]] 属性的方式是 `Object.prototype.toString`。在 ES5 开始，[[class]] 私有属性被 `Symbol.toStringTag` 代替。

```javascript
// 以下代码展示了所有具有内置 class 属性的对象
var o = new Object;
var n = new Number;
var s = new String;
var b = new Boolean;
var d = new Date;
var arg = function(){ return arguments }();
var r = new RegExp;
var f = new Function;
var arr = new Array;
var e = new Error;
console.log([o, n, s, b, d, arg, r, f, arr, e].map(v => Object.prototype.toString.call(v))); 

[
    "[object Object]",
    "[object Number]",
    "[object String]",
    "[object Boolean]",
    "[object Date]",
    "[object Arguments]",
    "[object RegExp]",
    "[object Function]",
    "[object Array]",
    "[object Error]"
]

// 使用 Symbol.toStringTag 来自定义 Object.prototype.toString 的行为
var o = { [Symbol.toStringTag]: "MyObject" }
console.log(o + ""); // [object MyObject]
// 这里创建了一个新对象，并且给它唯一的一个属性 Symbol.toStringTag，我们用字符串加法触发了 Object.prototype.toString 的调用，发现这个属性最终对 Object.prototype.toString 的结果产生了影响
var o = {
    [Symbol.toStringTag]: "MyObject",
    toString() {
        console.log("重写toString");
        return "abc";
    }
}
console.log(o + "");
```

- **JavaScript 语法中 new 操作具体做了哪些事情**：要把 new 理解成 JavaScript 面向对象的一部分。new 运算接受一个构造器和一组调用参数，实际上做了几件事：以构造器的 prototype 属性（注意与私有字段 [[prototype]] 的区分）为原型，创建新对象；将 this 和调用参数传给构造器，执行；如果构造器返回的是对象，则返回，否则返回第一步创建的对象。new 这样的行为，试图让函数对象在语法上跟类变得相似，但是，它客观上提供了两种方式，一是在构造器中添加属性，二是在构造器的 prototype 属性上添加属性。

```javascript
// 下面代码展示了用构造器模拟类的两种方法
// 1、直接在构造器中修改 this，给 this 添加属性
function c1 () {
    this.p1 = 1;
    this.p2 = function () {
        console.log(this.p1);
    }
} 
var o1 = new c1;
o1.p2();

// 2、修改构造器的 prototype 属性指向的对象
function c2 () {
}
c2.prototype.p1 = 1;
c2.prototype.p2 = function () {
    console.log(this.p1);
}
var o2 = new c2;
o2.p2();
```

```javascript
// Object.create 的不完整的 polyfill（一个是不支持第二个参数，另一个是不支持 null 作为原型）
Object.create = function(prototype){
    var cls = function(){}
    cls.prototype = prototype;
    return new cls;
}
```

- ES6 中的类：好在 ES6 中加入了新特性 class，new 跟 function 搭配的怪异行为终于可以退休了（虽然运行时没有改变），在任何场景，我都推荐使用 ES6 的语法来定义类，而令 function 回归原本的函数语义。ES6 中引入了 class 关键字，并且在标准中删除了所有[[class]]相关的私有属性描述，类的概念正式从属性升级成语言的基础设施。类提供了继承能力。

```javascript
// 类的基本写法
class Animal { 
  // 数据型成员最好写在构造器里面
  constructor(name) {
    this.name = name;
  }
  
  speak() {
    console.log(this.name + ' makes a noise.');
  }
}

class Dog extends Animal {
  constructor(name) {
    super(name); // call the super class constructor and pass in the name parameter
  }

  speak() {
    console.log(this.name + ' barks.');
  }
}

let d = new Dog('Mitzie');
d.speak(); // Mitzie barks.
```



### JavaScript对象：你知道全部的对象分类吗

- JavaScript 的对象机制并非简单的属性集合 + 原型。
- JavaScript 中的对象分类：【1】**宿主对象（host Objects）**：由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。【2】**内置对象（Built-in Objects）**：由 JavaScript 语言提供的对象。固有对象（Intrinsic Objects ）：由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。原生对象（Native Objects）：可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象。普通对象（Ordinary Objects）：由 {} 语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承。
- 宿主对象：前端最熟悉的无疑是浏览器环境中的宿主，window 对象。
- 内置对象：【1】固有对象：在任何 JavaScript 代码执行前就已经被创建出来了，它们通常扮演着类似基础库的角色。ECMA 标准为我们提供了一份固有对象表，里面含有 150+ 个固有对象。你可以通过[这个链接](https://262.ecma-international.org/9.0/#sec-well-known-intrinsic-objects)查看。【2】原生对象：JavaScript 标准中，提供了 30 多个构造器。通过这些构造器，用 new 运算创建新的对象，所以我们把这些对象称作原生对象。几乎所有这些构造器的能力都是**无法用纯 JavaScript 代码实现**的，它们也无法用 class/extend 语法来继承。

![img](https://static001.geekbang.org/resource/image/6c/d0/6cb1df319bbc7c7f948acfdb9ffd99d0.png)

```javascript
// 构造器创建的对象多数使用了私有字段
// 这些字段使得原型继承方法无法正常工作，所有这些原生对象都是为了特定能力或者性能，而设计出来的“特权对象”
Error: [[ErrorData]]
Boolean: [[BooleanData]]
Number: [[NumberData]]
Date: [[DateValue]]
RegExp: [[RegExpMatcher]]
Symbol: [[SymbolData]]
Map: [[MapData]]
```

- 用对象来模拟函数与构造器：**函数对象与构造器对象**。在 JavaScript 中，还有一个看待对象的不同视角，这就是用对象来模拟函数和构造器。事实上，JavaScript 为这一类对象预留了私有字段机制。函数对象的定义是：具有 `[[call]]` 私有字段的对象，构造器对象的定义是：具有私有字段 `[[construct]]` 的对象。对于宿主和内置对象来说，它们实现[[call]]（作为函数被调用）和[[construct]]（作为构造器被调用）不总是一致的。

```javascript
// 内置对象 Date 在作为构造器调用时产生新的对象，作为函数时则产生字符串
typeof new Date // 'object'
typeof Date() // 'string'

// 浏览器宿主环境中，提供的 Image 构造器，则根本不允许被作为函数调用
typeof new Image // 'object'
Image() // 抛出错误

// 基本类型（String、Number、Boolean），它们的构造器被当作函数调用，则产生类型转换的效果

// 在 ES6 之后 => 语法创建的函数仅仅是函数，它们无法被当作构造器使用
new (a => 0) // error

// 对于用户使用 function 语法或者 Function 构造器创建的对象来说，[[call]]和[[construct]]行为总是相似的，它们执行同一段代码
function f(){
    return 1;
}
var v = f(); // 把 f 作为函数调用
var o = new f(); // 把 f 作为构造器调用

// [[construct]] 的执行过程
// 以 Object.prototype 为原型创建一个新对象；以新对象为 this，执行函数的 [[call]]；如果 [[call]] 的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象。
```

- 特殊行为的对象：在固有对象和原生对象中它们常见的下标运算（就是使用中括号或者点来做属性访问）或者设置原型跟普通对象不同，这里简单总结一下：【1】Array：Array 的 length 属性根据最大的下标自动发生变化。【2】Object.prototype：作为所有正常对象的默认原型，不能再给它设置原型了。【3】String：为了支持下标运算，String 的正整数属性访问会去字符串里查找。【4】Arguments：arguments 的非负整数型下标属性跟对应的变量联动。【5】模块的 namespace 对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import 吧。【6】类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。【7】bind 后的 function：跟原来的函数相关联。
- 获取全部 JavaScript 固有对象：从 JavaScript 标准中可以找到全部的 JavaScript 对象定义。JavaScript 语言规定了全局对象的属性。【1】三个值：`Infinity、NaN、undefined`。【2】九个函数：`eval、isFinite、isNaN、parseFloat、parseInt、decodeURI、decodeURIComponent、encodeURI、encodeURIComponent`。【3】一些构造器：`Array、Date、RegExp、Promise、Proxy、Map、WeakMap、Set、WeakSet、Function、Boolean、String、Number、Symbol、Object、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError、ArrayBuffer、SharedArrayBuffer、DataView、Typed Array、Float32Array、Float64Array、Int8Array、Int16Array、Int32Array、UInt8Array、UInt16Array、UInt32Array、UInt8ClampedArray`。【4】四个用于当作命名空间的对象：`Atomics、JSON、Math、Reflect`。

```javascript
// 使用广度优先搜索，查找这些对象所有的属性和 Getter/Setter
var set = new Set();
var objects = [
    eval,
    isFinite,
    isNaN,
    parseFloat,
    parseInt,
    decodeURI,
    decodeURIComponent,
    encodeURI,
    encodeURIComponent,
    Array,
    Date,
    RegExp,
    Promise,
    Proxy,
    Map,
    WeakMap,
    Set,
    WeakSet,
    Function,
    Boolean,
    String,
    Number,
    Symbol,
    Object,
    Error,
    EvalError,
    RangeError,
    ReferenceError,
    SyntaxError,
    TypeError,
    URIError,
    ArrayBuffer,
    SharedArrayBuffer,
    DataView,
    Float32Array,
    Float64Array,
    Int8Array,
    Int16Array,
    Int32Array,
    Uint8Array,
    Uint16Array,
    Uint32Array,
    Uint8ClampedArray,
    Atomics,
    JSON,
    Math,
    Reflect];
objects.forEach(o => set.add(o));

for(var i = 0; i < objects.length; i++) {
    var o = objects[i]
    for(var p of Object.getOwnPropertyNames(o)) {
        var d = Object.getOwnPropertyDescriptor(o, p)
        if( (d.value !== null && typeof d.value === "object") || (typeof d.value === "function"))
            if(!set.has(d.value))
                set.add(d.value), objects.push(d.value);
        if( d.get )
            if(!set.has(d.get))
                set.add(d.get), objects.push(d.get);
        if( d.set )
            if(!set.has(d.set))
                set.add(d.set), objects.push(d.set);
    }
}
```



### JavaScript执行（一）：Promise里的代码为什么比setTimeout先执行

- 我们首先应该形成一个感性的认知：一个 **JavaScript 引擎会常驻于内存中**，它等待着我们（宿主）把 JavaScript 代码或者函数传递给它执行。
- 在 ES3 和更早的版本中，JavaScript 本身还没有异步执行代码的能力，这也就意味着，宿主环境传递给 JavaScript 引擎一段代码，引擎就把代码直接顺次执行了，这个任务也就是宿主发起的任务。但是，在 ES5 之后，JavaScript 引入了 Promise，这样，不需要浏览器的安排，JavaScript 引擎本身也可以发起任务了。
- 由于我们这里主要讲 JavaScript 语言，那么采纳 JSC 引擎（[参考](https://www.cnblogs.com/accordion/p/4962479.html)）的术语，我们把**宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务**。
- 宏观和微观任务：JavaScript 引擎等待宿主环境分配宏观任务，在操作系统中，通常等待的行为都是一个事件循环，所以在 Node 术语中，也会把这个部分称为**事件循环**。【1】在宏观任务中，JavaScript 的 Promise 还会产生异步代码，JavaScript 必须保证这些异步代码在一个宏观任务中完成，因此，**每个宏观任务中又包含了一个微观任务队列**。【2】有了宏观任务和微观任务机制，我们就可以实现 JavaScript 引擎级和宿主级的任务了，例如：Promise 永远在队列尾部添加微观任务。setTimeout 等宿主 API，则会添加宏观任务。

```javascript
// 事件循环的原理
// 在底层的 C/C++ 代码中，这个事件循环是一个跑在独立线程中的循环，我们用伪代码来表示
while(TRUE) {
    r = wait();
    execute(r);
}
// 整个循环做的事情基本上就是反复“等待 - 执行”
// 这里每次的执行过程，其实都是一个宏观任务。我们可以大概理解：宏观任务的队列就相当于事件循环。
```

- Promise：Promise 是 JavaScript 语言提供的一种标准化的异步管理方式，它的总体思想是，需要进行 io、等待或者其它异步操作的函数，不返回真实结果，而返回一个“承诺”，函数的调用方可以在合适的时机，选择等待这个承诺兑现（通过 Promise 的 then 方法的回调）。

```javascript
// Promise 的基本用法
function sleep(duration) {
    return new Promise(function(resolve, reject) {
        setTimeout(resolve,duration);
    })
}
sleep(1000).then( ()=> console.log("finished"))
```

- 总结一下如何分析异步执行的顺序：首先我们分析有多少个宏任务；在每个宏任务中，分析有多少个微任务；根据调用次序，确定宏任务中的微任务执行次序；根据宏任务的触发规则和调用次序，确定宏任务的执行次序；确定整个顺序。
- 新特性 `async/await`：async/await 是 ES2016 新加入的特性，它提供了用 for、if 等代码结构来编写异步的方式。它的运行时基础是 Promise。**async 函数必定返回 Promise，我们把所有返回 Promise 的函数都可以认为是异步函数。**async 函数是一种特殊语法，特征是在 function 关键字之前加上 async 关键字，这样，就定义了一个 async 函数，我们可以在其中使用 await 来等待一个 Promise。
- `generator/iterator` 也常常被跟异步一起来讲，我们必须说明 **generator/iterator 并非异步代码**，只是在缺少 async/await 的时候，一些框架（最著名的要数 co）使用这样的特性来模拟 async/await。但是 generator 并非被设计成实现异步，所以有了 async/await 之后，generator/iterator 来模拟异步的方法应该被废弃。

- 小练习：实现一个红绿灯，把一个圆形 div 按照绿色 3 秒，黄色 1 秒，红色 2 秒循环改变背景色。

```javascript
function sleep(duration){
    return new Promise(function(resolve){
        setTimeout(resolve, duration);
    })
}
async function changeColor(duration,color){
    document.getElementById("traffic-light").style.background = color;
    await sleep(duration);

}
async function main(){
    while(true){
        await changeColor(3000,"green");
        await changeColor(1000, "yellow");
        await changeColor(2000, "red");
    }
}
main()
```



### JavaScript执行（二）：闭包和执行上下文到底是怎么回事

- 主要内容：闭包；作用域链；执行上下文；this 值。尽管它们是表示不同的意思的术语，所指向的几乎是同一部分知识，那就是**函数执行过程相关的知识**。

![img](https://static001.geekbang.org/resource/image/68/52/68f50c00d475a7d6d8c7eef6a91b2152.png)

- 闭包：翻译自英文单词 closure，这是个不太好翻译的词，在计算机领域，它就有三个完全不相同的意义：编译原理中，它是处理语法产生式的一个步骤；计算几何中，它表示包裹平面点集的凸多边形（翻译作凸包）；而在**编程语言领域，它表示一种函数**。我们可以这样简单理解一下，**闭包其实只是一个绑定了执行环境的函数**，这个函数并不是印在书本里的一条简单的表达式，闭包与普通函数的区别是，它携带了执行的环境，就像人在外星中需要自带吸氧的装备一样，这个函数也带有在程序中生存的环境。【1】古典的闭包定义中，闭包包含两个部分：环境部分（环境、标识符列表）；表达式部分。【2】根据古典定义，在 JavaScript 中找到对应的闭包组成部分：环境部分（环境：函数的词法环境（执行上下文的一部分）、标识符列表：函数中用到的未声明的变量）；表达式部分：函数体。
- 闭包主要用来解决局部变量无法长期保存（函数运行结束函数作用域就被销毁了）。
- 执行上下文：**执行的基础设施**。相比普通函数，JavaScript 函数的主要复杂性来自于它携带的 “环境部分”。**JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”**。

```markdown
1、执行上下文在 ES3 中，包含三个部分：
● scope：作用域，也常常被叫做作用域链；
● variable object：变量对象，用于存储变量的对象；
● this value：this 值。

2、执行上下文在 ES5 中，最初的三个部分改进了命名方式：
● lexical environment：词法环境，当获取变量时使用；
● variable environment：变量环境，当声明变量时使用；
● this value：this 值。

3、在 ES2018 中，执行上下文又变成了这个样子，this 值被归入 lexical environment：
● lexical environment：词法环境，当获取变量或者 this 值时使用；
● variable environment：变量环境，当声明变量时使用；
● code evaluation state：用于恢复代码执行位置；
● Function：执行的任务是函数时使用，表示正在被执行的函数；
● ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码；
● Realm：使用的基础库和内置对象实例；
● Generator：仅生成器上下文有这个属性，表示当前生成器。
```

- 从代码实例出发，推导函数执行过程中需要哪些信息，它们又对应着执行上下文中的哪些部分：

```javascript
var b = {};
let c = 1;
this.a = 2;
// var 把 b 声明到哪里；
// b 表示哪个变量；
// b 的原型是哪个对象；
// let 把 c 声明到哪里；
// this 指向哪个对象。
```

- var 声明与赋值：分析一段代码，`var b = 1`。通常我们认为它声明了 b，并且为它赋值为 1，var 声明作用域是函数执行的作用域。也就是说，**var 会穿透 for 、if 等语句**。【1】在只有 var，没有 let 的旧 JavaScript 时代，诞生了一个技巧，叫做：立即执行的函数表达式（IIFE），通过创建一个函数，并且立即执行，来构造一个新的域，从而控制 var 的范围。【2】由于语法规定了 function 关键字开头是**函数声明**，所以要想让函数变成**函数表达式**，我们必须得加点东西，最常见的做法是加括号。【3】立即执行函数的更好的写法：`void function(){}()`。语义上 void 运算表示忽略后面表达式的值，直接变成 undefined，我们确实不关心 IIFE 的返回值，所以语义也更为合理。

```javascript
(function(){
    var a;
    //code
}());
(function(){
    var a;
    //code
})();

// 但是，括号有个缺点，那就是如果上一行代码不写分号，括号会被解释为上一行代码最末的函数调用，产生完全不符合预期，并且难以调试的行为，加号等运算符也有类似的问题。
// 所以一些推荐不加分号的代码风格规范，会要求在括号前面加上分号。
;(function(){
    var a;
    //code
}())
;(function(){
    var a;
    //code
})()

// 我比较推荐的写法是使用 void 关键字，立即执行函数的更好的写法
void function(){
    var a;
    //code
}();
```

```javascript
// 有时候 var 的特性会导致声明的变量和被赋值的变量是两个 b，使用 with 的时候
var b;
void function(){
    var env = {b:1};
    b = 2;
    console.log("In function b:", b);
    with(env) {
        var b = 3;
        console.log("In with b:", b);
    }
}();
console.log("Global b:", b);
```

- let：是 ES6 开始引入的**新的变量声明模式**，比起 var 的诸多弊病，let 做了非常明确的梳理和规定。为了实现 let，JavaScript 在运行时引入了**块级作用域**。在 let 出现之前，JavaScript 的 if、for 等语句皆不产生作用域。以下语句会产生 let 使用的作用域：`for；if；switch；try/catch/finally`。
- Realm：在最新的标准（9.0）中，JavaScript 引入了一个新概念 Realm，它的中文意思是“国度”“领域”“范围”。看这段代码：`var b = {}`，在 ES2016 之前的版本中，标准中甚少提及 `{}` 的原型问题。但在实际的前端开发中，通过 iframe 等方式创建多 window 环境并非罕见的操作，所以，这才促成了新概念 Realm 的引入。**Realm 中包含一组完整的内置对象，而且是复制关系。**【Realm 可以理解为 JavaScript 的命名空间，虽然每个里面的固定数据类型是一样的，但是不在同一个空间里，镜像一样】

```javascript
// 在浏览器环境中获取来自两个 Realm 的对象
// 它们跟本土的 Object 做 instanceOf 时会产生差异
var iframe = document.createElement('iframe');
document.documentElement.appendChild(iframe);
iframe.src="javascript:var b = {};";

var b1 = iframe.contentWindow.b;
var b2 = {};

console.log(b1 instanceof Object, b2 instanceof Object); // false true
// 由于 b1、 b2 由同样的代码“ {} ”在不同的 Realm 中执行，所以表现出了不同的行为。
```

```javascript
var b = 10;
(function b(){
b = 20;
console.log(b); // [Function: b]
})();
// 这个地方比较特殊，"具有名称的函数表达式"会在外层词法环境和它自己执行产生的词法环境之间产生一个词法环境，再把自己的名称和值当作变量塞进去，所以这里的b = 20 并没有改变外面的b，而是试图改变一个只读的变量b。
// 在同一个作用域内，同名函数会覆盖变量；同名变量会被忽略。
```



### JavaScript执行（三）：你知道现在有多少种函数吗以及this关键字

- **在 JavaScript，切换上下文最主要的场景是函数调用**。
- 函数：在 ES2018 中，函数已经是一个很复杂的体系。【1】第一种，**普通函数**：用 function 关键字定义的函数。【2】第二种，**箭头函数**：用 => 运算符定义的函数。【3】第三种，**方法**：在 class 中定义的函数。`class C { foo() { // code } }`。【4】第四种，**生成器函数**：用 function * 定义的函数。【5】第五种，**类**：用 class 定义的类，实际上也是函数。【6】**异步函数**：普通函数、箭头函数和生成器函数加上 **async 关键字**。（都是遵循了 **“继承定义时环境”** 的规则，它们的行为差异在于 this 关键字）
- this 关键字的行为：this 是 JavaScript 中的一个关键字，它的使用方法类似于一个变量（但是 this 跟变量的行为有很多不同）。this 是执行上下文中很重要的一个组成部分，同一个函数调用方式不同，得到的 this 值也不同。普通函数的 this 值由 **“调用它所使用的引用”** 决定，其中奥秘就在于：我们获取函数的表达式，它实际上返回的并非函数本身，而是一个 Reference 类型。【1】Reference 类型由两部分组成：一个对象和一个属性值。【2】**调用函数时使用的引用，决定了函数执行时刻的 this 值**。【3】箭头函数，不论用什么引用来调用它，都不影响它的 this 值。【4】es6 中类和模块的内部，默认就是严格模式，所以不需要使用 `use strict` 指定运行模式。在严格模式和非严格模式下函数中的 this 值会有不同，类默认为严格模式，函数在进入执行环境时没有设置 this 的值，this 会保持为 undefined。

```javascript
function showThis () {
    console.log(this);
}
var o = {
    showThis: showThis
}

showThis(); // global
o.showThis(); // o
// o.showThis 产生的 Reference 类型，即由对象 o 和属性 “showThis” 构成


class C {
    showThis() {
        console.log(this);
    }
}
var o = new C();
var showThis = o.showThis;
showThis(); // undefined
o.showThis(); // o
// 方法的行为跟普通函数有差异，恰恰是因为 class 设计成了默认按 strict 模式执行。
```

- this 关键字的机制：在 JavaScript 标准中，为函数规定了用来保存定义时上下文的私有属性`[[Environment]]`。当一个函数执行时，会创建一条新的执行环境记录，记录的外层词法环境（`outer lexical environment`）会被设置成函数的 `[[Environment]]`。这个动作就是切换上下文。【1】this 是一个更为复杂的机制，JavaScript 标准定义了 `[[thisMode]]` 私有属性。有三个取值：lexical，表示从上下文中找 this，这对应了箭头函数；global，表示当 this 为 undefined 时，取全局对象，对应了普通函数；strict，当严格模式时使用，this 严格按照调用时传入的值，可能为 null 或者 undefined。
- 操作 this 的内置函数：`Function.prototype.call` 和 `Function.prototype.apply` 可以指定函数调用时传入的 this 值。`Function.prototype.bind` 它可以生成一个绑定过的函数。call、bind 和 apply 作用于不接受 this 的函数类型时如箭头、class 都不会报错，它们无法实现改变 this 的能力，但是可以实现传参。
- **仅普通函数和类能够跟 new 搭配使用**。



### JavaScript执行（四）：try里面放return，finally还会执行吗

- 语句是任何编程语言的基础结构。比较常见的语句包括变量声明、表达式、条件、循环等。
- 小实验：finally 中的内容必须保证执行，所以 try/catch 执行完毕，即使得到的结果是非 normal 型的完成记录，也必须要执行 finally。而当 finally 执行也得到了非 normal 记录，则会使 finally 中的记录作为整个 try 结构的结果。

```javascript
function foo(){
  try{
    return 0;
  } catch(err) {

  } finally {
    console.log("a")
  }
}
console.log(foo()); // a 0

function foo(){
  try{
    return 0;
  } catch(err) {

  } finally {
    return 1;
  }
}
console.log(foo()); // 1
```

- Completion 类型：JavaScript 语句执行的完成状态，我们用一个标准类型来表示：`Completion Record`，用于描述异常、跳出等语句执行过程。表示一个语句执行完之后的结果，它有三个字段：`[[type]]` 表示完成的类型，有 break continue return throw 和 normal 几种类型；`[[value]]` 表示语句的返回值，如果语句没有，则是 empty；`[[target]]` 表示语句的目标，通常是一个 JavaScript 标签（标签在后文会有介绍）。语句有几种分类：

![img](https://static001.geekbang.org/resource/image/98/d5/98ce53be306344c018cddd6c083392d5.jpg)

- 普通的语句：把不带控制能力的语句称为普通语句。普通语句执行后，会得到 [[type]] 为 normal 的 Completion Record，JavaScript 引擎遇到这样的 Completion Record，会继续执行下一条语句。
- 语句块：就是拿大括号括起来的一组语句，它是一种语句的复合结构，可以嵌套。
- 控制型语句：会对不同类型的 Completion Record 产生反应。控制类语句分成两部分，一类是对其内部造成影响，如 if、switch、while/for、try；另一类是对外部造成影响如 break、continue、return、throw，这两类语句的配合，会产生控制代码执行顺序和执行逻辑的效果，这也是我们编程的主要工作。

![img](https://static001.geekbang.org/resource/image/77/d3/7760027d7ee09bdc8ec140efa9caf1d3.png)

- 带标签的语句：是 JavaScript 中的一个语法。大部分时候，这个东西类似于注释，没有任何用处。唯一有作用的时候是，与完成记录类型中的 target 相配合，用于**跳出多层循环**。

```javascript
// 任何 JavaScript 语句是可以加标签的，在语句前加冒号即可
firstStatement: var i = 1;

outer: while(true) {
    inner: while(true) {
        break outer;
    }
}
console.log("finished")
```



### JavaScript词法：为什么12.toString会报错

- 文法是编译原理中对语言的写法的一种规定，一般来说，**文法分成词法和语法两种**。**词法规定了语言的最小语义单元**：token，可以翻译成 “标记” 或者 “词”。
- 词法概述：以下这个设计符合比较通用的编程语言设计方式。也有一些特别之处：【1】首先是除法和正则表达式冲突问题。对词法分析来说，其实是没有办法处理的，所以 JavaScript 的解决方案是定义两组词法，然后靠语法分析传一个标志给词法分析器，让它来决定使用哪一套词法。【2】另一个特别设计是字符串模板。理论上，`“ ${ } ”` 内部可以放任何 JavaScript 表达式代码，而这些代码是以 `“ } ”`  结尾的，也就是说，这部分词法不允许出现 `“ } ”` 运算符。【3】要实现 JavaScript 的解释器，词法分析和语法分析非常麻烦，需要来回传递信息。

```markdown
先来看一看 JavaScript 的词法定义，JavaScript 源代码中的输入可以这样分类：
1、WhiteSpace 空白字符
2、LineTerminator 换行符
3、Comment 注释
4、Token 词：
● IdentifierName 标识符名称，典型案例是我们使用的变量名，注意这里关键字也包含在内了。
● Punctuator 符号，我们使用的运算符和大括号等符号。
● NumericLiteral 数字直接量，就是我们写的数字。
● StringLiteral 字符串直接量，就是我们用单引号或者双引号引起来的直接量。
● Template 字符串模板，用反引号 ` 括起来的直接量。

是否允许 “}” 的两种情况，与除法和正则表达式的两种情况相乘就是四种词法定义，所以在 JavaScript 标准中，可以看到四种定义：
● InputElementDiv；
● InputElementRegExp；
● InputElementRegExp；
● InputElementTemplateTail。
```

- 空白符号 Whitespace：印象中就是空格，但是实际上，JavaScript 可以支持更多空白符号。【1】U+0009，是缩进 TAB 符，也就是字符串中写的 \t。【2】U+0020，就是最普通的空格。【3】U+00A0，非断行空格，多数的 JavaScript 编辑环境都会把它当做普通空格，HTML 中的  `& nbsp;` 最后生成的就是它了。【4】U+FEFF，这是 ES5 新加入的空白符，是 Unicode 中的零宽非断行空格。
- 换行符 LineTerminator：JavaScript 中只提供了 4 种字符作为换行符，【1】`<LF>` U+000A，就是最正常换行符，在字符串中的 `\n`。【2】`<CR>` U+000D，这个字符真正意义上的 “回车”，在字符串中是 `\r`，在一部分 Windows 风格文本编辑器中，换行是两个字符 `\r\n`。【3】`<LS>` U+2028，是 Unicode 中的行分隔符。【4】`<PS>` U+2029，是 Unicode 中的段落分隔符。大部分 LineTerminator 在被词法分析器扫描出之后，会被语法分析器丢弃，但是换行符会影响 JavaScript 的两个重要语法特性：自动插入分号和 `“no line terminator”` 规则。
- 注释 Comment：分为单行注释和多行注释两种。

```javascript
/* MultiLineCommentChars */ 
// SingleLineCommentChars
```

- 标识符名称 IdentifierName：可以以**美元符 “$”、下划线 “_” 或者 Unicode 字母开始**，除了开始字符以外，IdentifierName 中还可以使用 **Unicode 中的连接标记、数字、以及连接符号**。IdentifierName 的任意字符可以使用 JavaScript 的 Unicode 转义写法。

```javascript
// 注意和是 ES5 新加入的两个格式控制字符，它们都是 0 宽的。

// 关键字也属于这个部分，在 JavaScript 中，关键字有:
await break case catch class const continue debugger default delete do else export extends finally for function if import instanceof new return super switch this throw try typeof var void while with yield
// 除了上述的内容之外，还有 1 个为了未来使用而保留的关键字:
enum
// 在严格模式下, 有一些额外的为未来使用而保留的关键字:
implements package protected interface private public
```

- 符号 Punctuator：所有符号为：

```javascript
{ ( ) [ ] . ... ; , < > <= >= == != === !== + - * % ** ++ -- << >> >>> & | ^ ! ~ && || ? : = += -= *= %= **= <<= >>= >>>= &= |= ^= => / /= }
```

- 数字直接量 NumericLiteral：JavaScript 规范中规定的数字直接量可以支持四种写法，十进制数、二进制整数、八进制整数和十六进制整数。

```javascript
// 十进制的 Number 可以带小数，小数点前后部分都可以省略，但是不能同时省略
.01
12.
12.01
// 这都是合法的数字直接量。这里就有一个问题，也是我们标题提出的问题
// 需要写成：12..toString() 或 12 .toString() 就没事
12.toString() // Uncaught SyntaxError: Invalid or unexpected token

// 数字直接量还支持科学计数法
10.24E+2
10.24e-2
10.24e2

// 当以0x 0b 或者0o 开头时，表示特定进制的整数 16 / 2 / 8
0xFA
0o73
0b10000
```

- 字符串直接量 StringLiteral：支持单引号和双引号两种写法。
- 正则表达式直接量 RegularExpressionLiteral：正则表达式由 Body 和 Flags 两部分组成，例如，`/RegularExpressionBody/g`。【1】正则表达式有自己的语法规则，在词法阶段，仅会对它做简单解析。【2】正则表达式并非机械地见到 / 就停止，在正则表达式 [ ] 中的 / 就会被认为是普通字符。【3】除了 \、/ 和 [ 三个字符之外，JavaScript 正则表达式中的字符都是普通字符。
- 字符串模板 Template：从语法结构上，Template 是个整体，其中的 `${ }` 是并列关系。但是实际上，在 JavaScript 词法中，包含 ${ } 的 Template，是被拆开分析的。

```javascript
`a${b}c${d}e`
// 被拆开分析：
模板头：   `a${
普通标识符：b
模板中段：  }c${
普通标识符：d
模板尾：   }e`
```

```javascript
// 模板支持添加处理函数的写法，这时模板的各段会被拆开，传递给函数当参数：
function f(){
    console.log(arguments);
}
var a = "world"
f`Hello ${a}!`; // [["Hello ", "!"], world]
```

- **零宽空格和零宽连接符、零宽非连接符**：有妙用，如隐形水印、加密信息分享和逃脱关键词匹配。



### （小实验）理解编译原理：一个四则运算的解释器

- 分析：按照编译原理相关的知识，这里分成几个步骤，【1】定义四则运算：产出四则运算的词法定义和语法定义。【2】词法分析：把输入的字符串流变成 token。【3】语法分析：把 token 变成抽象语法树 AST。【4】解释执行：后序遍历 AST，执行得出结果。
- 定义四则运算：四则运算就是加减乘除四种运算。首先我们来定义词法，四则运算里面只有数字和运算符；接下来我们来定义语法，语法定义多数采用 `BNF`；语法定义的核心思想不会变，都是几种结构的组合产生一个新的结构，所以语法定义也叫**语法产生式**。
- 词法分析：词法分析有两种方案，**一种是状态机，一种是正则表达式**，它们是等效的。
- 语法分析：**LL 语法分析**根据每一个产生式来写一个函数。实际上一般编译代码都应该支持流式处理。
- 解释执行：得到了 AST 之后，最困难的一步我们已经解决了。接下来，直接进入执行阶段，我们只需要对这个树做遍历操作执行即可。根据不同的节点类型和其它信息，写 if 分别处理即可。



### JavaScript语法（预备篇）：到底要不要写分号呢

- 语言风格问题：究竟要不要写分号。实际上，行尾使用分号的风格来自于 Java，也来自于 C 语言和 C++，这一设计最初是**为了降低编译器的工作负担**。
- 自动插入分号规则：独立于所有的语法产生式定义，它的规则说起来非常简单，只有三条。要有换行符，且下一个符号是不符合语法的，那么就尝试插入分号；有换行符，且语法中规定此处不能有换行符，那么就自动插入分号；源代码结束处，不能形成完整的脚本或者模块结构，那么就自动插入分号。
- `no LineTerminator here` 规则：表示它所在的结构中的这一位置不能插入换行符。

![img](https://static001.geekbang.org/resource/image/c3/ad/c3ffbc89e049ad1901d4108c8ad88aad.jpg)

- 不写分号容易造成错误的情况：以括号开头的语句；以数组开头的语句；以正则表达式开头的语句；以 Template 开头的语句。



### JavaScript语法（一）：在script标签写export为什么会抛错

- 脚本和模块：JavaScript 有两种**源文件**，一种叫做脚本，一种叫做模块。这个区分是在 ES6 引入了模块机制开始的，在 ES5 和之前的版本中，就只有一种源文件类型（就只有脚本）。【1】脚本是可以由浏览器或者 node 环境引入执行的，而模块只能由 JavaScript 代码用 import 引入执行。【2】从概念上，我们可以认为脚本具有主动性的 JavaScript 代码段，是控制宿主完成一定任务的代码；而模块是被动性的 JavaScript 代码段，是等待被调用的库。【3】现代浏览器支持用 script 标签引入模块或者脚本，如果要引入模块，必须给 script 标签添加 `type=“module”`。如果引入脚本，则不需要 type。【4】script 标签如果不加 type=“module”，默认认为我们加载的文件是脚本而非模块，如果我们在脚本中写了 export，当然会抛错。

```javascript
<script type="module" src="xxxxx.js"></script>
```

![img](https://static001.geekbang.org/resource/image/43/44/43fdb35c0300e73bb19c143431f50a44.jpg)

- import 声明：有两种用法，一个是直接 import 一个模块（只是保证了这个模块代码被执行）；另一个是带 from 的 import，它能引入模块里的一些信息，可以把它们变成本地的变量。

```javascript
import "mod"; // 引入一个模块
import v from "mod";  // 把模块默认的导出值放入变量v
```

- export 声明：承担的是导出的任务。模块中导出变量的方式有两种，一种是独立使用 export 声明，另一种是直接在声明型语句前添加 export 关键字。export 还有一种特殊的用法，就是跟 default 联合使用。export default 表示导出一个**默认变量值**。

```javascript
// 独立使用 export 声明就是一个 export 关键字加上变量名列表，例如：
export { a, b, c };

// 这里的行为跟导出变量是不一致的，这里导出的是值，导出的就是普通变量 a 的值，以后 a 的变化与导出的值就无关了，修改变量 a，不会使得其他模块中引入的 default 值发生改变
// export导出的是变量的引用（浅拷贝），但是 export default 表达式导出的是变量的值（深拷贝）
var a = {};
export default a;

// 在 import 语句前无法加入 export，但是我们可以直接使用 export from 语法
export a from "a.js"
```

- 函数体：宏任务中可能会执行的代码包括 **“脚本 (script)”、“模块（module）” 和 “函数体（function body）”**。函数体其实也是一个语句的列表，跟脚本和模块比起来，函数体中的语句列表中多了 return 语句可以用。函数体实际上有四种，普通函数体、异步函数体、生成器函数体、异步生成器函数体（区别在于，能否使用 await 或者 yield 语句）。

```javascript
// 异步生成器函数体
async function *foo () {
    // Function body
}
```

![img](https://static001.geekbang.org/resource/image/0b/50/0b24e78625beb70e3346aad1e8cfff50.jpg)

- 两个 JavaScript 语法的**全局机制：预处理和指令序言**。（指令序言 --> 严格模式）
- 预处理：JavaScript 执行前，会对脚本、模块和函数体中的语句进行预处理。预处理过程将会提前处理 var、函数声明、class、const 和 let 这些语句，以确定其中变量的意义。【1】**var 声明永远作用于脚本、模块和函数体这个级别**。var 除了脚本和函数体都会穿透，人民群众发明了 “立即执行的函数表达式（IIFE）”这一用法，用来产生作用域。

```javascript
// 预处理过程在执行之前，所以有函数体级的变量 a，就不会去访问外层作用域中的变量 a 了，而函数体级的变量 a 此时还没有赋值，所以是 undefined
var a = 1;
function foo () {
    console.log(a);
    var a = 2;
}
foo(); // undefined

// var 的作用能够穿透一切语句结构，它只认脚本、模块和函数体三种语法结构
var a = 1;
function foo() {
    console.log(a);
    if(false) {
        var a = 2;
    }
}
foo(); // undefined

// 预处理处理了 var，那时候的作用域是函数体级别的；而程序运行到 with 的时候，a 被对象的属性劫持了
var a = 1;
function foo () {
    var o = { a: 3 }
    with (o) {
        var a = 2;
    }
    console.log(o.a); // 2
    console.log(a); // undefined
}
foo();

// IIFE
for(var i = 0; i < 20; i ++) {
    void function(i){
        var div = document.createElement("div");
        div.innerHTML = i;
        div.onclick = function(){
            console.log(i);
        }
        document.body.appendChild(div);
    }(i);
}
```

- function 声明：function 声明的行为原本跟 var 非常相似，但是在最新的 JavaScript 标准中，对它进行了一定的修改。在**全局（脚本、模块和函数体）**，function 声明表现跟 var 相似，不同之处在于，function 声明不但在作用域中加入变量，还会给它赋值。

```javascript
console.log(foo); // f
function foo(){
    
}

console.log(foo); // f / node --> undefined
if(true) {
    function foo(){
        
    }
}
```

- class 声明：class 声明在全局的行为跟 function 和 var 都不一样。【1】class 声明也是会被预处理的，它会在作用域中创建变量，并且要求访问它时抛出错误。【2】class 的声明作用不会穿透 if 等语句结构，所以只有写在全局环境才会有声明作用。
- 指令序言机制：脚本和模块都支持一种特别的语法，叫做指令序言（Directive Prologs）。【1】`"use strict"` 是 JavaScript 标准中规定的唯一一种指令序言， 如果 `"use strict"` 没有出现在最前，就不是指令序言。但是设计指令序言的目的是，留给 JavaScript 的引擎和实现者一些统一的表达方式，在静态扫描时指定 JavaScript 代码的一些特性。【2】JavaScript 的指令序言是只有一个字符串直接量的表达式语句，它只能出现在脚本、模块和函数体的最前面。



### JavaScript语法（二）：你知道哪些JavaScript语句

- 在 JavaScript 标准中，把语句分成了两种：**普通语句**和**声明型语句**。
- 语句块：就是一对大括号。**语句块会产生作用域**。
- 空语句：就是一个独立的**分号**，实际上没什么大用。`;` 就这。
- if 语句：条件语句，if 语句的作用是，在满足条件时执行它的内容语句，这个语句可以是一个语句块。
- switch 语句：继承自 Java，Java 中的 switch 语句继承自 C 和 C++，原本 switch 语句是跳转的变形，所以我们如果要用它来**实现分支，必须要加上 break**。
- 循环语句：【1】while 循环和 do while 循环。【2】普通 for 循环。【3】for in 循环：循环枚举对象的属性，这里体现了属性的 enumerable 特征。【4】for of 循环和 for await of 循环：for of 循环是非常棒的语法特性，但是实际上，它背后的机制是 iterator 机制。
- return：用于函数中，它终止函数的执行，并且指定函数的返回值。
- break 语句和 continue 语句：break 语句用于跳出循环语句或者 switch 语句，continue 语句用于结束本次循环并继续循环。这两个语句都属于控制型语句。
- with 语句：with 语句是个非常巧妙的设计，但它把 JavaScript 的变量引用关系变得不可分析，所以一般都认为这种语句都属于糟粕。with 语句把对象的属性在它内部的作用域内变成变量。
- try 语句和 throw 语句：用于处理异常。【1】try 部分用于标识捕获异常的代码段，catch 部分则用于捕获异常后做一些处理，而 finally 则是用于执行后做一些必须执行的清理工作。【2】一般来说，throw 用于抛出异常，但是单纯从语言的角度，我们可以抛出任何值，也不一定是异常逻辑，但是为了保证语义清晰，不建议用 throw 表达任何非异常逻辑。
- debugger 语句：通知调试器在此断点。
- **以上都是普通语句，下面的是声明型语句**。声明型语句跟普通语句最大区别就是**声明型语句响应预处理过程**，**普通语句只有执行过程**。
- var：是古典的 JavaScript 中声明变量的方式。
- let 和 const：新设计的语法，所以没有什么硬伤，非常地符合直觉。let 和 const 的作用范围是 if、for 等结构型语句。let 和 const 语句在重复声明时会抛错，这能够有效地避免变量名无意中冲突。
- class 声明：最基本的用法只需要 class 关键字、名称和一对大括号。它的声明特征跟 const 和 let 类似，都是作用于块级作用域，预处理阶段则会屏蔽外部变量。

```javascript
const a = 2;
if(true){
    console.log(a); //抛错
    class a {

    }
}
```

- 函数声明：使用 function 关键字。



### JavaScript语法（三）：什么是表达式语句

- 什么是表达式语句：实际上就是一个表达式，它是由运算符连接变量或者直接量构成的。一般来说，我们的表达式语句要么是函数调用，要么是赋值，要么是自增、自减。下面就来了解下都有哪些表达式，我们从粒度最小到粒度最大了解一下。
- PrimaryExpression 主要表达式：表达式的原子项，是表达式的最小单位，它所涉及的语法结构也是优先级最高的。包含了各种 “直接量”，直接量就是直接用某种语法写出来的具有特定类型的值。【1】Primary Expression 还可以是 this 或者变量，在语法上，把变量称作 “标识符引用”。【2】任何表达式加上圆括号，都被认为是 Primary Expression，这个机制使得圆括号成为改变运算优先顺序的手段。

```javascript
this;
myVar;

(a + b);
```

- MemberExpression 成员表达式：通常是用于访问对象成员的，最初设计是为了属性访问的。它有几种形式：【1】`new.target` 是个新加入的语法，用于判断函数是否是被 new 调用。【2】super 则是构造函数中，用于访问父类的属性的语法。

```javascript
a.b;
a["b"];
new.target; // 是一个整体
super.b;
```

- NewExpression NEW 表达式：这种非常简单，Member Expression 加上 new 就是 New Expression（当然，不加 new 也可以构成 New Expression，**JavaScript 中默认独立的高优先级表达式都可以构成低优先级表达式**）。

```javascript
// 稍微复杂的例子：
new new Cls(1);

// 等价于:
new (new Cls(1));

// 可以用以下代码来验证：
class Cls{
  constructor(n){
    console.log("cls", n);
    return class {
      constructor(n) {
        console.log("returned", n);
      }
    }
  }
}
new (new Cls(1));
// cls 1
// returned undefined
```

- CallExpression 函数调用表达式：除了 New Expression，Member Expression 还能构成 Call Expression。它的基本形式是 Member Expression 后加一个括号里的参数列表，或者我们可以用上 super 关键字代替 Member Expression。

```javascript
a.b(c);
super();

// 一些变体，比如：
a.b(c)(d)(e);
a.b(c)[3];
a.b(c).d;
a.b(c)`xyz`;
```

- LeftHandSideExpression 左值表达式：New Expression 和 Call Expression 统称 LeftHandSideExpression，**左值表达式，就是可以放到等号左边的表达式**。
- AssignmentExpression 赋值表达式：也有多种形态，最基本的当然是使用等号赋值：

```javascript
a = b
// 这个等号是可以嵌套的：
a = b = c = d
// 这样的连续赋值，是右结合的，它等价于下面这种：
a = (b = (c = d))

// 赋值表达式的使用，还可以结合一些运算符，例如：
a += b; // a = a + b;
// *=、/=、%=、+=、-=、<<=、>>=、>>>=、&=、^=、|=、**=
```

- Expression 表达式：在 JavaScript 中，**表达式就是用逗号运算符连接的赋值表达式**。比赋值运算优先级更低的就是逗号运算符了，可以把逗号可以理解为一种小型的分号。

```javascript
a = b, b = 1, null;
// 逗号分隔的表达式会顺次执行，就像不同的表达式语句一样。
// “整个表达式的结果” 就是 “最后一个逗号后的表达式结果”。 --> null
```



### JavaScript语法（四）：新加入的**运算符，哪里有些不一样呢

- 在一些通用的计算机语言设计理论中，能够出现在赋值表达式右边的叫做：右值表达式（RightHandSideExpression），而在 JavaScript 标准中，规定了在等号右边表达式叫做**条件表达式**（ConditionalExpression），不过，在 JavaScript 标准中，从未出现过右值表达式字样。JavaScript 标准也规定了左值表达式同时都是条件表达式（也就是右值表达式）。
- 更新表达式 UpdateExpression：左值表达式搭配  `++ --`  运算符，可以形成更新表达式。在 ES2018 中，跟早期版本有所不同，前**后**自增自减运算被放到了同一优先级。
- 一元运算表达式 UnaryExpression：更新表达式搭配一元运算符，可以形成一元运算表达式。

```javascript
delete a.b;
void a;
typeof a;
- a;
~ a;
! a;
await a;
// 它的特点就是一个更新表达式搭配了一个一元运算符。
```

- 乘方表达式 ExponentiationExpression：乘方表达式也是由更新表达式构成的，它使用 `**` 号。`**` 运算是右结合。`4 ** 3 ** 2 --> 4 ** (3 ** 2)`。
- 乘法表达式 MultiplicativeExpression：乘方表达式可以构成乘法表达式，用乘号或者除号、取余符号连接就可以了。`x * 2;`。
- 加法表达式 AdditiveExpression：加法表达式是由乘法表达式用加号或者减号连接构成的。`a + b * c`。不过要注意，**加号还能表示字符串连接**。
- 移位表达式 ShiftExpression：移位表达式由加法表达式构成，移位是一种位运算。移位运算把操作数看做二进制表示的整数，然后移动特定位数。所以左移 n 位相当于乘以 2 的 n 次方，右移 n 位相当于除以 2 取整 n 次。（在 JavaScript 中，二进制操作整数并不能提高性能，移位运算这里也仅仅作为一种数学运算存在，这些运算存在的意义也仅仅是照顾 C 系语言用户的习惯了）

```javascript
<< 向左移位
>> 向右移位
>>> 无符号向右移位

// 普通移位会保持正负数。无符号移位会把减号视为符号位 1，同时参与移位：
-1 >>> 1 // 2147483647
```

- 关系表达式 RelationalExpression：移位表达式可以构成关系表达式，这里的关系表达式就是大于、小于、大于等于、小于等于等运算符号连接，统称为关系运算。`<=  >=  <  >  instanceof  in`。**需要注意，这里的 <= 和 >= 关系运算，完全是针对数字的**。
- 相等表达式 EqualityExpression：相等表达式是由关系表达式用相等比较运算符（如 ==）连接构成的。`==  !=  ===  !==`。**包含一个 JavaScript 中著名的设计失误，那就是 == 的行为**。
- 位运算表达式：把操作数视为**二进制整数**，然后把两个操作数按位做**与 / 异或 / 或**运算。按位与表达式 BitwiseANDExpression（&）、按位异或表达式 BitwiseANDExpression（^，两位相同时得 0，两位不同时得 1）、按位或表达式 BitwiseORExpression（|）。
- 逻辑与表达式和逻辑或表达式：逻辑表达式具有短路的特性。
- 条件表达式 ConditionalExpression：又称三目运算符，它有三个部分，由两个运算符 `?` 和 `:` 配合使用。



## 3. 模块二：HTML和CSS

### HTML语义：div和span不是够用了吗

- **语义类标签**是什么，使用它有什么好处：在很多工作场景里，语义类标签也有它们自己无可替代的优点，正确地使用语义标签可以带来很多好处。【1】语义类标签对开发者更为友好，使用语义类标签增强了可读性，也更为便于团队的开发和维护。【2】除了对人类友好之外，语义类标签也十分适宜机器阅读，更适合搜索引擎检索（SEO）。
- 错误地使用语义标签，会给机器阅读造成混淆、增加嵌套，给 CSS 编写加重负担。
- 作为**自然语言延伸**的语义类标签：【1】使用的第一个场景，也是最自然的使用场景，就是作为自然语言和纯文本的补充，用来表达一定的结构或者消除歧义。（在 HTML5 中，就引入了这个表示 `ruby` 的标签，它由 ruby、rt、rp 三个标签来实现）【2】还有一种情况是，HTML 的有些标签实际上就是必要的，甚至必要的程度可以达到：如果没有这个标签，文字会产生歧义的程度。（ `em` 标签）
- 作为**标题摘要**的语义类标签：中国古代小说就形成了 “章 - 回” 的概念，西方的戏剧也有幕的区分，所以人类的自然语言作品也是如出一辙。从 HTML 5 开始，我们有了 `section` 标签，这个标签可不仅仅是一个 “有语义的 div”，它会改变 h1-h6 的语义，section 的嵌套会使得其中的 h1-h6 下降一级。
- 作为**适合机器阅读的整体结构**的语义类标签：我们想介绍的最后一个场景是，随着越来越多的浏览器推出 “阅读模式”，以及各种非浏览器终端的出现，语义化的 HTML 适合机器阅读的特性变得越来越重要。应用了语义化结构的页面，可以明确地提示出**页面信息的主次关系**，它能让浏览器很好地**支持 “阅读视图功能”**，还可以让**搜索引擎的命中率提升**，同时，它也**对视障用户的读屏软件更友好**。



### HTML语义：如何运用语义类标签来呈现Wiki网页

- Wikipedia 文章，这种跟论文相似的网站比较适合用来学习语义类标签。通过分析一篇 Wiki 的文章用到的语义类标签，来进一步帮你理解语义的概念。[https://en.wikipedia.org/wiki/World_Wide_Web](https://en.wikipedia.org/wiki/World_Wide_Web)，副本：[http://static001.geekbang.org/static/time/quote/World_Wide_Web-Wikipedia.html](http://static001.geekbang.org/static/time/quote/World_Wide_Web-Wikipedia.html)。



