---
title: 重学前端
date: 2021-06-22
categories:
 - 随笔
tags:
 - 极客时间
---

<!-- more -->



## 1. 开篇词 + 学习路线 + 架构图

### 开篇词 | 从今天起，重新理解前端

- keywords：软件工程体系；UI 架构；浏览器的工作原理；前端工程化；程序员通用的编程能力和架构能力。

- 关于前端工程师成长，需要两个视角。一是立足标准，系统性总结和整理前端知识，建立自己的认知和方法论；二是放眼团队，从业务和工程角度思考前端团队的价值和发展需要。只有这样做，才能够持续发展，在高速发展的技术和工程浪潮中稳稳立足。



### 明确你的前端学习路线与方法

- keywords：前端的基础知识；前端学习方法；知识架构；前端技术背后的核心思想；**基于原型的语言**。

- 前端学习方法：【1】建立知识架构；【2】追本溯源。


- 文法  -->  语义  -->  运行时；对于任何计算机语言来说，必定是“用规定的文法，去表达特定语义，最终操作运行时的”一个过程。


- 文法：词法、语法；语义；运行时：类型、执行过程。（词法中有各种直接量、关键字、运算符，语法和语义则是表达式、语句、函数、对象、模块，类型则包含了对象、数字、字符串等……）


- **程序 = 算法 + 数据结构**，对运行时来说，类型就是数据结构，执行过程就是算法。
- JavaScript 之父 Brendan Eich 曾经在 Wikipedia 的讨论页上解释 JavaScript 最初想设计一个带有 prototype 的 scheme，结果受到管理层命令把它弄成像 Java 的样子。（为什么javascript最初设计成prototype-based而不是class-based，[链接](https://www.zhihu.com/question/27689001)）

::: tip
前端基础 -> 函数库 -> 组件库 -> 框架 -> 工程化。
:::



### 前端知识架构图

- keywords：MDN。

- 前端的知识在总体上分成基础部分和实践部分，基础部分包含了 JavaScript 语言（模块一）、CSS 和 HTML（模块二）以及浏览器的实现原理和 API（模块三），这三个模块涵盖了一个前端工程师所需要掌握的全部知识。


#### JavaScript

![img](https://static001.geekbang.org/resource/image/6a/9b/6aec0a09381a2f74014ec604ef99c19b.png)

在 JavaScript 的模块中，首先我们可以把语言按照文法、语义和运行时来拆分，这符合**编程语言的一般规律：用一定的词法和语法，表达一定语义，从而操作运行时**。

接下来，我们又按照程序的一般规律，把运行时分为数据结构和算法部分：数据结构包含类型和实例（JavaScript 的类型系统就是它的 7 种基本类型和 7 种语言类型，实例就是它的内置对象部分）。所谓的算法，就是 JavaScript 的执行过程。

#### HTML 和 CSS

![img](https://static001.geekbang.org/resource/image/41/62/4153891927afac7f4c21ccf6a141f062.png)

在 HTML 的部分，基于这样的分类，我把标签元素分成下面几种：

文档元信息：通常是出现在 head 标签中的元素，包含了描述文档自身的一些信息；

语义相关：扩展了纯文本，表达文章结构、不同语言要素的标签；

链接：提供到文档内和文档外的链接；

替换型标签：引入声音、图片、视频等外部元素替换自身的一类标签；

表单：用于填写和提交信息的一类标签；

表格：表头、表尾、单元格等表格的结构。

除了标签之外，我们还应该把 HTML 当作一门语言来了解下，当然，标记语言跟编程语言不太一样，没有编程语言那么严谨，所以，我们会简要介绍 HTML 的语法和几个重要的语言机制：实体、命名空间。最后我们会介绍下 HTML 的补充标准：ARIA，它是 HTML 的扩展，在可访问性领域，它有至关重要的作用。

#### 浏览器的实现原理和 API

![img](https://static001.geekbang.org/resource/image/cb/cb/cbb6d198ccfb95af4906eeb0581333cb.png)

浏览器部分我们会先介绍下浏览器的实现原理，这是我们深入理解 API 的基础。会从一般的浏览器设计出发，按照解析、构建 DOM 树、计算 CSS、渲染、合成和绘制的流程来讲解浏览器的工作原理。

#### 前端工程实践

![img](https://static001.geekbang.org/resource/image/45/ce/4568011037a5591402c4ba1547ba0dce.jpg)

性能：对任何一个前端团队而言，性能是它价值的核心指标，从早年“重构”的实践开始，前端有通过性能证明自己价值的传统。但是性能并非细节的堆砌，也不是默默做优化，所以，我会从团队的角度来跟你一起探讨性能的方法论和技术体系。

工具链：探讨企业中工具链的建设思路。对一个高效又合作良好的前端团队来说，一致性的工具链是不可或缺的保障，作为开发阶段的入口，工具链又可以和性能、发布、持续集成等系统链接到一起，成为团队技术管理的基础。

持续集成：持续集成并非一个新概念，但是过去持续集成概念和理论都主要针对软件开发，而对前端来说，持续集成是一个新的课题（当然对持续集成来说，前端也是一个新课题），比如 daily build 就完全不适用前端，前端代码必须是线上实时可用的。

搭建系统：前端工作往往多而繁杂，针对高重复性、可模块化的业务需求，传统的人工开发不再适用，搭建系统是大部分大型前端团队的选择。

架构与基础库：软件架构师主要解决功能复杂性的问题，服务端架构师主要解决高流量问题，而前端是页面间天然解耦，分散在用户端运行的系统，但是前端架构也有自己要解决的问题。前端需求量大、专业人才稀缺，更因为前端本身运行在浏览器中，有大量兼容工作要做。所以前端架构的主要职责是兼容性、复用和能力扩展。

![img](https://static001.geekbang.org/resource/image/d1/a8/d1cb4040d91207075e0591abffe1b9a8.jpg)

## 2. 模块一：JavaScript

### JavaScript类型：关于类型，有哪些你不知道的细节

- 类型：JavaScript 语言的每一个值都属于某一种数据类型。JavaScript 语言规定了 7 种语言类型。语言类型广泛用于变量、函数参数、表达式、函数返回值等场合。根据最新的语言标准，这 7 种语言类型是：Undefined；Null；Boolean；String；Number；Symbol；Object。


#### Undefined、Null

- 为什么有的编程规范要求用 void 0 代替 undefined：Undefined 类型表示未定义，它的类型只有一个值，就是 undefined。任何变量在赋值前是 Undefined 类型、值为 undefined，一般我们可以用全局变量 undefined（就是名为 undefined 的这个变量）来表达这个值，或者 void 运算来把任意一个表达式变成 undefined 值。但是呢，因为 JavaScript 的代码 undefined 是一个**变量**，而并非是一个**关键字**，这是 JavaScript 语言公认的设计失误之一，所以，我们为了避免无意中被篡改，我建议使用 void 0 来获取 undefined 值。


- Undefined 跟 Null 有一定的表意差别，Null 表示的是：“定义了但是为空”。所以，在实际编程时，我们一般**不会把变量赋值为 undefined**，这样可以保证所有值为 undefined 的变量，都是从未赋值的自然状态。


- Null 类型也只有一个值，就是 null，它的语义表示空值，与 undefined 不同，null 是 JavaScript 关键字，所以在任何代码中，你都可以放心用 null 关键字来获取 null 值。


#### Boolean

- Boolean 类型有两个值， true 和 false，它用于表示逻辑意义上的真和假，同样有关键字 true 和 false 来表示两个值。


#### String

- 字符串是否有最大长度？


- String 用于表示文本数据。String 有最大长度是 2^53 - 1，这在一般开发中都是够用的，但是有趣的是，这个所谓最大长度，并不完全是你理解中的字符数。


- 因为 String 的意义并非“字符串”，而是**字符串的 UTF16 编码**，我们字符串的操作 charAt、charCodeAt、length 等方法针对的都是 UTF16 编码。所以，字符串的最大长度，实际上是受**字符串的编码长度**影响的。


- JavaScript 中的字符串是永远无法变更的，一旦字符串构造出来，无法用任何方式改变字符串的内容，所以字符串具有值类型的特征。


- JavaScript 字符串把每个 UTF16 单元当作一个字符来处理，所以处理非 BMP（超出 U+0000 - U+FFFF 范围）的字符时，你应该格外小心。【0-65536（U+0000 - U+FFFF）的码点被称为基本字符区域（BMP）】


- JavaScript 这个设计继承自 Java，最新标准中是这样解释的，这样设计是为了“性能和尽可能实现起来简单”。因为现实中很少用到 BMP 之外的字符。


#### Number

- Number 类型表示我们通常意义上的“数字”。这个数字大致对应数学中的有理数，当然，在计算机中，我们有一定的精度限制。JavaScript 中的 Number 类型有 18437736874454810627(即 2^64-2^53+3) 个值。
- JavaScript 中的 Number 类型基本符合 IEEE 754-2008 规定的双精度浮点数规则，但是 JavaScript 为了表达几个额外的语言场景（比如不让除以 0 出错，而引入了无穷大的概念），规定了几个例外情况：NaN，占用了 9007199254740990，这原本是符合 IEEE 规则的数字；Infinity，无穷大；-Infinity，负无穷大。

- 另外，值得注意的是，JavaScript 中有 +0 和 -0，在加法类运算中它们没有区别，但是除法的场合则需要特别留意区分，“忘记检测除以 -0，而得到负无穷大”的情况经常会导致错误，而区分 +0 和 -0 的方式，正是检测 1/x 是 Infinity 还是 -Infinity。


- 根据双精度浮点数的定义，Number 类型中有效的整数范围是 -0x1fffffffffffff 至 0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数。【支持数值范围是：-2^53~2^53，即：- 9007199254740991(0x1FFFFFFFFFFFFF)～9007199254740991(0x1FFFFFFFFFFFFF)。】


- 同样根据浮点数的定义，非整数的 Number 类型无法用 ==（=== 也不行） 来比较，一段著名的代码，为什么在 JavaScript 中，0.1+0.2 不能 =0.3：【非整形的数字有精度要求，所以不相等；事实上不是无法比较，浮点数是可以比较的，不过由于精度的问题可能导致一些在计算中理所当然的结果并不会出现，所以 JavaScript 才会规定浮点数不可以进行比较】


- Number 类型运算都要想将其转化为二进制，将二进制运算，运算的结果再转化为十进制，因为 Number 是64位双精度，小数部分只有52位，但0.1转化成为二进制是无限循环的，所以四舍五入了，这里就发生了精度丢失，0.1的二进制和0.2的二进制相加需要保留有效数字，所以又发生了精度丢失，所以结果为0.300000000000004，所以为false，而0.2+0.3恰好两个转化成为二进制和相加的过程都不会发生精度丢失，所以为true。


```javascript
console.log( 0.1 + 0.2 == 0.3);
```

- 这里输出的结果是 false，说明两边不相等的，这是浮点运算的特点，也是很多同学疑惑的来源，浮点数运算的精度问题导致等式左右的结果并不是严格相等，而是相差了个微小的值。


- 所以实际上，这里错误的不是结论，而是比较的方法，正确的比较方法是使用 JavaScript 提供的最小精度值；用最小精度比较，防止浮点数运算导致的精度问题造成结果错误：（检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法。这段代码结果就是 true 了）


```javascript
console.log( Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON);
```

#### Symbol

- Symbol 是 ES6 中引入的新类型，它是一切非字符串的对象 key 的集合，在 ES6 规范中，整个**对象系统**被用 Symbol 重塑。Symbol 跟对象系统的关系，在后面的文章中会详细叙述。在这里我们只介绍 Symbol 类型本身：它有哪些部分，它表示什么意思，以及如何创建 Symbol 类型。


- Symbol 可以具有字符串类型的描述，但是即使描述相同，Symbol 也不相等。


- 我们创建 Symbol 的方式是使用全局的 Symbol 函数。例如：


```javascript
var mySymbol = Symbol("my symbol");
```

- 一些标准中提到的 Symbol，可以在全局的 Symbol 函数的属性中找到。例如，我们可以使用 Symbol.iterator 来自定义 for…of 在对象上的行为：


```javascript
var o = new Object

o[Symbol.iterator] = function() {
    var v = 0
    return {
        next: function() {
            return { value: v++, done: v > 10 }
        }
    }        
};

for(var v of o) 
    console.log(v); // 0 1 2 3 ... 9
```

- 代码中我们定义了 iterator 之后，用 for(var v of o) 就可以调用这个函数，然后我们可以根据函数的行为，产生一个 for…of 的行为。这里我们给对象 o 添加了 Symbol.iterator 属性，并且按照迭代器的要求定义了一个 0 到 10 的迭代器，之后我们就可以在 for of 中愉快地使用这个 o 对象啦。


- 这些标准中被称为“众所周知”的 Symbol，也构成了语言的一类接口形式。它们允许编写与语言结合更紧密的 API。


#### Object

- Object 是 JavaScript 中最复杂的类型，也是 JavaScript 的核心机制之一。Object 表示对象的意思，它是一切有形和无形物体的总称。


- 为什么给对象添加的方法能用在基本类型上？


- 在 JavaScript 中，对象的定义是“属性的集合”。属性分为**数据属性**和**访问器属性**，二者都是 key-value 结构，key 可以是字符串或者 Symbol 类型。关于对象的机制，后面会有单独的一篇来讲述，这里我重点从类型的角度来介绍对象类型。提到对象，我们必须要提到一个概念：类。


- 因为 C++ 和 Java 的成功，在这两门语言中，每个类都是一个类型，二者几乎等同，以至于很多人常常会把 JavaScript 的“类”与类型混淆。事实上，JavaScript 中的“类”仅仅是运行时对象的一个私有属性，而 JavaScript 中是无法自定义类型的。


- JavaScript 中的几个基本类型，都在对象类型中有一个“亲戚”。它们是：Number；String；Boolean；Symbol。所以，我们必须认识到 3 与 new Number(3) 是完全不同的值，它们一个是 Number 类型， 一个是对象类型。
- Number、String 和 Boolean，三个构造器是两用的，当跟 new 搭配时，它们产生对象，当直接调用时，它们表示强制类型转换。Symbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。

- JavaScript 语言设计上试图模糊对象和基本类型之间的关系，我们日常代码可以把对象的方法在基本类型上使用，比如：


```javascript
console.log("abc".charAt(0)); // a
```

- 甚至我们在原型上添加方法，都可以应用于基本类型，比如以下代码，在 Symbol 原型上添加了 hello 方法，在任何 Symbol 类型变量都可以调用。


```javascript
Symbol.prototype.hello = () => console.log("hello");

var a = Symbol("a");
console.log(typeof a); //symbol，a并非对象
a.hello(); //hello，有效
```

- 所以前面的问题【为什么给对象添加的方法能用在基本类型上】，答案就是  . 运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。


#### 类型转换

- 介绍一个**现象**：类型转换。


- 因为 JavaScript 是弱类型语言，所以类型转换发生非常频繁，大部分我们熟悉的运算都会先进行类型转换。大部分类型转换符合人类的直觉，但是如果我们不去理解类型转换的严格定义，很容易造成一些代码中的判断失误。其中最为臭名昭著的是 JavaScript 中的“ == ”运算，因为试图实现跨类型的比较，它的规则复杂到几乎没人可以记住。这里我们当然也不打算讲解 == 的规则，它属于设计失误，并非语言中有价值的部分，很多实践中推荐**禁止使用“ ==”**，而要求程序员进行显式地类型转换后，用 === 比较。【现在的实践中，项目基本上使用 eslint 配置一些检测规则，来规避 == 比较】


- 其它运算，如加减乘除大于小于，也都会涉及类型转换。幸好的是，实际上大部分类型转换规则是非常简单的，如下表所示：


![img](https://static001.geekbang.org/resource/image/71/20/71bafbd2404dc3ffa5ccf5d0ba077720.jpg)

- 在这个里面，较为复杂的部分是 Number 和 String 之间的转换，以及对象跟基本类型之间的转换。我们分别来看一看这几种转换的规则。


- StringToNumber

  字符串到数字的类型转换，存在一个语法结构，类型转换支持十进制、二进制、八进制和十六进制，比如：30；0b111；0o13；0xFF。

  此外，JavaScript 支持的字符串语法还包括正负号科学计数法，可以使用大写或者小写的 e 来表示：1e3；-1e-2。

  需要注意的是，parseInt 和 parseFloat 并不使用这个转换，所以支持的语法跟这里不尽相同。

  在不传入第二个参数的情况下，parseInt 只支持 16 进制前缀“0x”，而且会忽略非数字字符，也不支持科学计数法。

  在一些古老的浏览器环境中，parseInt 还支持 0 开头的数字作为 8 进制前缀，这是很多错误的来源。所以在任何环境下，都建议传入 parseInt 的第二个参数，而 parseFloat 则直接把原字符串作为十进制来解析，它不会引入任何的其他进制。

  多数情况下，`Number` 是比 `parseInt` 和 `parseFloat` 更好的选择。【**Number**函数推荐使用】

- NumberToString

  在较小的范围内，数字到字符串的转换是完全符合你直觉的十进制表示。当 Number 绝对值较大或者较小时，字符串表示则是使用科学计数法表示的。这个算法细节繁多，我们从感性的角度认识，它其实就是保证了产生的字符串不会过长。

  `toString` 方法：不能转化 underfind 和 null；`String` 方法；`num +  ‘ ’` 。

- 装箱转换

  每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓**装箱转换，正是把基本类型转换为对应的对象**，它是类型转换中一种相当重要的种类。

  前文提到，全局的 Symbol 函数无法使用 new 来调用，但我们仍可以利用装箱机制来得到一个 Symbol 对象，我们可以利用一个函数的 call 方法来强迫产生装箱。我们定义一个函数，函数里面只有 return this，然后我们调用函数的 call 方法到一个 Symbol 类型的值上，这样就会产生一个 symbolObject。

  我们可以用 console.log 看一下这个东西的 typeof，它的值是 object，我们使用 symbolObject instanceof 可以看到，它是 Symbol 这个类的实例，我们找它的 constructor 也是等于 Symbol 的，所以我们无论从哪个角度看，它都是 Symbol 装箱过的对象：

  ```javascript
  var symbolObject = (function(){ return this; }).call(Symbol("a"));
  
  console.log(typeof symbolObject); // object
  console.log(symbolObject instanceof Symbol); // true
  console.log(symbolObject.constructor == Symbol); // true
  ```

  **装箱机制会频繁产生临时对象**，在一些对性能要求较高的场景下，我们应该尽量避免对基本类型做装箱转换。

  使用内置的 **Object 函数**，我们可以在 JavaScript 代码中显式调用装箱能力。

  ```javascript
  var symbolObject = Object(Symbol("a"));
  
  console.log(typeof symbolObject); //object
  console.log(symbolObject instanceof Symbol); //true
  console.log(symbolObject.constructor == Symbol); //true
  ```

  每一类装箱对象皆有私有的 **Class 属性**，这些属性可以用 Object.prototype.toString 获取：

  ```javascript
  var symbolObject = Object(Symbol("a"));
  
  console.log(Object.prototype.toString.call(symbolObject)); //[object Symbol]
  ```

  在 JavaScript 中，**没有任何方法可以更改私有的 Class 属性**，因此 `Object.prototype.toString` 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。

  但需要注意的是，call 本身会产生装箱操作，所以需要配合 typeof 来区分基本类型还是对象类型。

- 拆箱转换

  在 JavaScript 标准中，规定了 ToPrimitive 函数，它是**对象类型到基本类型的转换（即，拆箱转换）**。

  对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。

  拆箱转换会尝试调用 `valueOf` 和 `toString` 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 `TypeError`。

  ```javascript
  var o = {
  valueOf : () => {console.log("valueOf"); return {}},
  toString : () => {console.log("toString"); return {}}
  }
  
  o * 2
  // valueOf
  // toString
  // TypeError
  ```

  我们定义了一个对象 o，o 有 valueOf 和 toString 两个方法，这两个方法都返回一个对象，然后我们进行 o*2 这个运算的时候，你会看见先执行了 valueOf，接下来是 toString，最后抛出了一个 TypeError，这就说明了这个拆箱转换失败了。

  到 String 的拆箱转换会优先调用 toString。我们把刚才的运算从 o*2 换成 String(o)，那么你会看到调用顺序就变了。

  ```javascript
  var o = {
  valueOf : () => {console.log("valueOf"); return {}},
  toString : () => {console.log("toString"); return {}}
  }
  
  String(o)
  // toString
  // valueOf
  // TypeError
  ```

  在 ES6 之后，还允许对象通过显式指定 @@`toPrimitive` Symbol 来覆盖原有的行为。

  ```javascript
  var o = {
  valueOf : () => {console.log("valueOf"); return {}},
  toString : () => {console.log("toString"); return {}}
  }
  
  o[Symbol.toPrimitive] = () => {console.log("toPrimitive"); return "hello"}
  
  
  console.log(o + "")
  // toPrimitive
  // hello
  ```

#### 结语

在本篇文章中，我们介绍了 JavaScript 运行时的类型系统。

除了这七种**语言类型**，还有一些语言的实现者更关心的**规范类型**。

- List 和 Record： 用于描述函数传参过程。
- Set：主要用于解释字符集等。
- Completion Record：用于描述异常、跳出等语句执行过程。
- Reference：用于描述对象属性访问、delete 等。
- Property Descriptor：用于描述对象的属性。
- Lexical Environment 和 Environment Record：用于描述变量和作用域。
- Data Block：用于描述二进制数据。

有一个说法是：**程序 = 算法 + 数据结构**，运行时类型包含了所有 JavaScript 执行时所需要的数据结构的定义，所以我们要对它格外重视。

#### 补充

- 事实上，“类型”在 JavaScript 中是一个有争议的概念。一方面，标准中规定了运行时数据类型； 另一方面，JavaScript 语言中提供了 typeof 这样的运算，用来返回操作数的类型，但 typeof 的运算结果，与运行时类型的规定有很多不一致的地方。我们可以看下表来对照一下。


![img](https://static001.geekbang.org/resource/image/ec/6b/ec4299a73fb84c732efcd360fed6e16b.png)

- 在表格中，多数项是对应的，但是请注意 object——Null 和 function——Object 是特例，我们理解类型的时候需要特别注意这个区别。


- 从一般语言使用者的角度来看，毫无疑问，我们应该按照 typeof 的结果去理解语言的类型系统。但 JavaScript 之父本人也在多个场合表示过，typeof 的设计是有缺陷的，只是现在已经错过了修正它的时机。


- 不用原生的 number 和 parseInt，使用 JavaScript 实现从 string 到 number 的转换：


```javascript
function strToNum(a){
    let chars = a.split("").map(e => e.charCodeAt(0) - "0".charCodeAt(0));
    let n = 0;
    for(var char of chars){
        n *= 10;
      n += char;
    }
    return n;
}

strToNum("8947947")
```



### JavaScript对象：面向对象还是基于对象

- 在学习 JavaScript **面向对象**时，往往也会有疑惑：为什么 JavaScript（直到 ES6）有对象的概念，但是却没有像其他的语言那样，有类的概念呢；为什么在 JavaScript 对象里可以自由添加属性，而其他的语言却不能呢。实际上，基于对象和面向对象两个形容词都出现在了 JavaScript 标准的各个版本当中。
- JavaScript 标准对基于对象的定义，这个定义的具体内容是：**“语言和宿主的基础设施由对象来提供，并且 JavaScript 程序即是一系列互相通讯的对象集合”**。这里的意思根本不是表达弱化的面向对象的意思，反而是表达**对象对于语言的重要性**。
- 什么是面向对象：【1】因为翻译的原因，中文语境下我们很难理解“对象”的真正含义。事实上，Object（对象）在英文中，是**一切事物的总称**，这和面向对象编程的抽象思维有互通之处。中文的“对象”却没有这样的普适性，我们在学习编程的过程中，更多是把它当作一个专业名词来理解。但不论如何，我们应该认识到，对象并不是计算机领域凭空造出来的概念，它是顺着**人类思维模式**产生的一种抽象（于是面向对象编程也被认为是：更接近人类思维模式的一种编程范式）。【2】在《面向对象分析与设计》这本书中，Grady Booch 替我们做了总结，他认为，从人类的认知角度来说，对象应该是下列事物之一：一个可以触摸或者可以看见的东西；人的智力可以理解的东西；可以指导思考或行动（进行想象或施加动作）的东西。【3】有了对象的自然定义后，我们就可以描述编程语言中的对象了。在不同的编程语言中，设计者也利用各种不同的语言特性来抽象描述对象，最为成功的流派是**使用“类”的方式来描述对象**，这诞生了诸如 C++、Java 等流行的编程语言。而 JavaScript 早年却选择了一个更为冷门的方式：**原型**，这也是说它不合群的原因之一。【4】如果我们从运行时角度来谈论对象，就是在讨论 JavaScript 实际运行中的模型，这是由于任何代码执行都必定绕不开**运行时的对象模型**。不过，幸运的是，从运行时的角度看，可以不必受到这些“基于类的设施”的困扰，这是因为任何语言**运行时类的概念都是被弱化的**。
- 在人类思维模式下，对象究竟是什么：对象这一概念在人类的幼儿期形成，这远远早于我们编程逻辑中常用的值、过程等概念。在幼年期，我们总是先认识到某一个苹果能吃（这里的某一个苹果就是一个对象），继而认识到所有的苹果都可以吃（这里的所有苹果，就是一个类），再到后来我们才能意识到三个苹果和三个梨之间的联系，进而产生数字“3”（值）的概念。
- **类和原型是编程语言来抽象描述对象的两种不同方式。**
- JavaScript 对象的特征：不论我们使用什么样的编程语言，我们都先应该去理解对象的本质特征。总结来看，对象有如下几个特点，【1】**对象具有唯一标识性（内存地址）**：即使完全相同的两个对象，也并非同一个对象。【2】**对象有状态**：对象具有状态，同一对象可能处于不同状态之下。【3】**对象具有行为**：即对象的状态，可能因为它的行为产生变迁。
- 关于对象的第二个和第三个特征“状态和行为”，不同语言会使用不同的术语来抽象描述它们，比如 C++ 中称它们为“**成员变量**”和“**成员函数**”，Java 中则称它们为“**属性**”和“**方法**”。在 JavaScript 中，将状态和行为统一抽象为“**属性**”，考虑到 JavaScript 中将函数设计成一种特殊对象，所以 **JavaScript 中的状态和行为都能用属性来抽象**。
- **在实现了对象基本特征的基础上, 我认为，JavaScript 中对象独有的特色是：对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。**为了提高抽象能力，JavaScript 的属性被设计成比别的语言更加复杂的形式，它提供了**数据属性**和**访问器属性（getter/setter）**两类。
- JavaScript 对象的两类属性：**数据属性和访问器属性**。对 JavaScript 来说，属性并非只是简单的名称和值，JavaScript 用一组特征（attribute）来描述属性（property）。【1】数据属性，它比较接近于其它语言的属性概念，具有**四个特征**。value：就是属性的值；writable：决定属性能否被赋值；enumerable：决定 for in 能否枚举该属性；configurable：决定该属性能否被删除或者改变特征值。在大多数情况下，我们只关心数据属性的值即可。【2】访问器（getter/setter）属性，它也有**四个特征**。getter：函数或 undefined，在取属性值时被调用；setter：函数或 undefined，在设置属性值时被调用；enumerable：决定 for in 能否枚举该属性；configurable：决定该属性能否被删除或者改变特征值。访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。【3】我们通常用于定义属性的代码会产生数据属性，其中的 writable、enumerable、configurable 都默认为 true。我们可以使用内置函数 `getOwnPropertyDescriptor` 来查看。【4】如果我们要想改变属性的特征，或者定义访问器属性，我们可以使用 `Object.defineProperty`。

```javascript
var o = { a: 1 };
o.b = 2;
// a 和 b 皆为数据属性
Object.getOwnPropertyDescriptor(o,"a")
// {value: 1, writable: true, enumerable: true, configurable: true}
Object.getOwnPropertyDescriptor(o,"b")
// {value: 2, writable: true, enumerable: true, configurable: true}
```

```javascript
var o = { a: 1 };
Object.defineProperty(o, "b", {value: 2, writable: false, enumerable: false, configurable: true});
// a 和 b 都是数据属性，但特征值变化了
Object.getOwnPropertyDescriptor(o,"a");
// {value: 1, writable: true, enumerable: true, configurable: true}
Object.getOwnPropertyDescriptor(o,"b");
// {value: 2, writable: false, enumerable: false, configurable: true}
o.b = 3;
console.log(o.b); // 2，因为 writable 特征为 false，所以我们重新对 b 赋值，b 的值不会发生变化
```

- 在创建对象时，也可以使用 get 和 set 关键字来创建访问器属性。访问器属性跟数据属性不同，每次访问属性都会执行 getter 或者 setter 函数。这里我们的 getter 函数返回了 1，所以 o.a 每次都得到 1。**实际上 JavaScript 对象的运行时是一个“属性的集合”，属性以字符串或者 Symbol 为 key，以数据属性特征值或者访问器属性特征值为 value。**

```javascript
var o = { get a() { return 1 } };
console.log(o.a); // 1
// “a”是 key
// {writable:true,value:1,configurable:true,enumerable:true}是 value
```

- 对象是一个属性的索引结构（索引结构是一类常见的数据结构，我们可以把它理解为一个能够以比较快的速度用 key 来查找 value 的字典）。
- 由于 JavaScript 的对象设计跟目前主流基于类的面向对象差异非常大。可事实上，这样的对象系统设计虽然特别，但是 JavaScript 提供了完全运行时的对象系统，这使得它可以模仿多数面向对象编程范式（ JavaScript 中两种**面向对象编程的范式：基于类和基于原型**），所以它也是正统的**面向对象语言**。
- **JavaScript 对象的具体设计：具有高度动态性的属性集合。**



