---
title: 一天时间迅速准备前端面试，快速构建初级前端知识体系
date: 2022-06-20
categories:
 - 随笔
tags:
 - 天下无鱼
---

<!-- more -->



> 源链接：[https://coding.imooc.com/class/400.html](https://coding.imooc.com/class/400.html)

:::tip

快速搞定前端技术一面 匹配大厂面试要求<br/>

迅速建立初中级前端面试（0 ~ 2年）JS 知识体系 掌握解决面试题的思路与技巧<br/>

**双越**：BAT 资深面试官针对时下面试高频考点，帮你解决面试问题。课程不局限于讲解单一知识点，而是以面试官的角度出发，带你了解前端面试中每个 “门道” 与 “套路”。手把手带你分析考点及解答策略，梳理 JS 考试体系。

:::



## 1. 课程介绍【说说面试的那些事儿】

- 关于面试：基层工程师 -- 基础知识；高级工程师 -- 基础知识 + 项目经验；架构师 -- 解决方案能力。
- 关于基础：工程师的自我修养 -- 基础知识；扎实的基础能让你高效学习新技术。
- 拿到一个面试题，第一时间看到 -- **考点**。面对题海看准考点。
- 什么是知识体系：结构化的知识范围，**结构化、有组织、易扩展**。



## 2. 面试前的准备【要知己知彼，不打无准备之仗】

- 投递简历的几种方式：员工内推、猎头推荐、HR 主动收集。
- 面试的主要环节：一面、二面（交叉面）、三面、HR 面。
- JD 分析：Job Description。职位描述、岗位要求。



## 3. CSS 面试题【不多说了，前端面试 CSS 是必考知识，不过关直接回家】

- 如何理解 HTML 语义化：让人更容易读懂，增加代码可读性； 让搜索引擎更容易读懂（SEO）。
- margin 负值问题：margin-top 负值，**元素向上移动**；margin-bottom 负值，**下方元素向上移动**；margin-left 负值，**元素向左移动**；margin-right 负值，**右侧元素向左移动**。
- 布局：BFC、float、flex。
- 定位：absolute、relative、fixed、垂直居中对齐。
- line-height 的继承：px -- 直接继承；比例 -- 比例 * 自己的 font-size；百分比 -- 百分比 * 父元素的 font-size。
- 响应式：`window.innerWidth === 100vw`、`window.innerHeight === 100vh`。



## 4. JS 基础-变量类型和计算【不会变量，别说你会 JS】

- typeof 能判断的类型：undefined、string、number、boolean、Symbol、function、object。
- instanceof：用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。**instanceof 是基于原型链实现的**。
- 函数（function）是特殊引用类型，但不用于存储数据，所以没有 “拷贝、复制函数” 这一说。
- 手写深拷贝。
- 注意某些类型转换的坑：字符串拼接、==、if 语句和逻辑运算 -- `&&、||`。
- truly 变量：`!! a === true`；falsely 变量：`!! a === false`。



## 5. JS 基础-原型和原型链【三座大山之一，必考！！！】

- 如何用 class 实现继承。
- `[] instanceof Array --> true`、`[] instanceof Object --> true`。
- `typeof Class --> function`。**class 实际上是函数**，可见是语法糖。
- 如何理解 JS 原型：隐式原型：`xiaowen.__proto__`  ===  显式原型：`People.prototype`。



## 6. JS 基础-作用域和闭包【三座大山之二，不会闭包，基本不会通过】 

- 作用域：全局作用域、函数作用域、块级作用域（ES6 新增）。
- 自由变量：一个变量在当前作用域没有定义，但被使用了；向上级作用域一层一层寻找；如果到全局作用域都没找到，则报错。在**函数定义时**查找。
- **闭包：作用域应用的特殊情况，有两种表现：函数作为参数被传递、函数作为返回值被返回**。存在自由变量查找规则。任何闭包的使用场景都离不开这两点：创建私有变量、延长变量的生命周期。
- this 的取值是在**函数执行时**决定的。
- 手写 bind 函数：

```javascript
// 模拟 bind
Function.prototype.myBind = function () {
  // 将参数拆解成数组
  const args = Array.prototype.slice.call(arguments);

  // 获取 this (数组的第一个元素)
  const t = args.shift();

  // 调用 myBind 的函数
  const self = this;

  // 返回一个函数
  return function () {
    return self.apply(t, args);
  }
}
```

- 实际开发中闭包的应用：隐藏数据、做一个简单的 cache 工具。
- 注意以下 let 位置的不同：

```javascript
let a
for (let i = 0; i < 10; i++) {
  a = document.createElement('a')
  a.innerHTML = i + '<br>'
  a.addEventListener('click', function (e) {
    e.preventDefault()
    alert(i)
  })
  document.body.appendChild(a)
}

let i, a
for (i = 0; i < 10; i++) {
  a = document.createElement('a')
  a.innerHTML = i + '<br>'
  a.addEventListener('click', function (e) {
    e.preventDefault()
    alert(i)
  })
  document.body.appendChild(a)
}
```



## 7. JS 基础-异步【三座大山之三，必考！！！】

- 同步和异步有何不同：基于 JS 是单线程语言；同步会阻塞代码执行；异步不会阻塞代码执行。
- 异步的应用场景：网络请求、定时任务。
- Promise：是**异步编程的一种解决方案**，解决 callback hell。

```javascript
Promise.resolve('foo');
// 等同于
new Promise(resolve => resolve('foo'));

Promise.reject('出错了');
// 等同于
new Promise((resolve, reject) => reject('出错了'));
```

- **JS 是单线程运行的，异步要基于回调来实现**。



## 8. JS 异步进阶【想要进大厂，更多异步的问题等着你】

- event loop：事件循环，事件轮询。就是异步回调的实现原理。**callback queue**。
- DOM 事件和 event loop 的关系：DOM 事件也是使用回调，基于 event loop。**回调 --> 异步 --> event loop**。
- DOM 渲染和 event loop 的关系：JS 的执行和 DOM 渲染公用一个线程。先尝试 DOM 渲染，再进行 event loop。**微任务在 DOM 渲染前，宏任务在 DOM 渲染后**（微任务执行早于宏任务的原因）。
- Promise 有哪三种状态：pending、resolved、rejected。【1】变化不可逆。【2】**resolved 触发后续 then 回调，rejected 触发后续 catch 回调**。【3】then 和 catch 影响状态的变化：**then、catch 正常返回 resolved，里面有报错则返回 rejected**。
- async-await 语法：是同步语法，彻底消除回调函数，**处理异步编程的最终方案**。【1】执行 async 函数，返回的是一个 Promise 对象。【2】await 相当于 Promise then。【3】try...catch 可捕获异常，代替 Promise 的 catch。【4】await 后面的代码，即下一排的代码开始，都可以看作是 callback 里面的内容，即异步，会启动 event loop。
- for...of 常用于异步的遍历，for...in、for、forEach 是常规的同步遍历。

```javascript
function multi(num) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(num * num);
    }, 1000)
  })
}
const nums = [1,2,3];
;(async function () {
  for (let i of nums) {
    // 在 for...of 循环体的内部，遇到 await 会挨个串行计算
    const res = await multi(x);
    console.log(res);
  }
})
```

- 宏任务和微任务。



## 9. JS-Web-API-DOM【学会 DOM，才能具备网页开发的基础】

- JS 基础知识，规定语法（ECMA 262 标准）；JS Web API，网页操作的 API（W3C 标准）。前者是后者的基础，两者结合才能真正实际应用。
- DOM 本质：Document Object Model，本质是一棵树。
- DOM 节点操作：获取节点、attribute（**修改 html 属性**，会改变 html 结构）、property（**修改对象属性**，不会体现到 html 结构中）。
- DOM 结构操作：新增/插入节点、获取子元素列表（nodeType、nodeName）、获取父元素、删除子元素。
- 优化 DOM 操作的性能：避免频繁的 DOM 操作（`document.createDocumentFragment()`）、对 DOM 查询做缓存（`document.getElementsByTagName('p').length`）。



## 10. JS-Web-API-BOM【内容虽然不多，但是你不能不会】

- BOM：Browser Object Model。知识点 -- `navigator、screen、location、history`。
- 如何识别浏览器类型：`navigator.userAgent`。
- 分析拆解 url 各个部分：`location`。



## 11. JS-Web-API-事件【事件不会，等于残废，必考！必考！】

- 事件绑定：`element.addEventListener('', event => {  })`。
- 事件冒泡：`event.preventDefault()`。
- 事件代理：依赖于事件冒泡。



## 12. JS-Web-API-Ajax【每个工程师必须熟练掌握的技能】

- XMLHttpRequest：ajax 的核心 API。

```javascript
const xhr = new XMLHttpRequest();
// true 表示异步
xhr.open('GET', 'https://api.github.com/users/diego3g', true);
xhr.onreadystatechange = function () {
  if (xhr.readyState === 4) {
    if (xhr.status === 200) {
      console.log(xhr.responseText);
    }
  }
}
xhr.send(null);
// post 请求
// xhr.send(JSON.stringify({ foo: 'foo' }));
```

- **浏览器**的同源策略：协议、域名(指向主机)、端口，只有这三个完全相同的 URL 才能称之为同源（安全）。加载图片、css、js 可无视同源策略。

```html
<img src='跨域的图片地址' />
<link href='跨域的css地址'/>
<script src='跨域的js地址'> <script/>
```

- 实现跨域的常见方式：JSONP、CORS。【1】JSONP：`<script>` 可绕过跨域限制、服务器可以任意动态拼接数据返回。【2】CORS：服务器设置 http header。



## 13. JS-Web-API-存储【内容虽然不多，但不可不会】

- cookie：`document.cookie = 'a=100'` 是一个追加的效果，而不是替换。缺点：存储大小，最大 4KB；请求时需要发送到服务端，增加请求数据量；不方便修改。
- localStorage、SessionStorage：HTML5 专门为存储而设计，最大可存 5M；API 简单易用，setItem / getItem；不会随着 http 请求被发送出去。



## 14. http 面试题【前后端分离的时代，网络请求是前端的生命线】

- http 状态码：【1】状态码分类：1xx -- 服务器收到请求、2xx -- 请求成功、3xx -- 重定向、4xx -- 客户端错误、5xx -- 服务端错误；【2】常见状态码：200、301 永久重定向、302 临时重定向、304 资源未修改使用缓存、403 没有权限、404、500、504 网关超时；【3】关于状态码的协议与规范：就是一个约定。
- http methods：get、post、patch / put、delete。
- Restful API：一种新的 API 设计方法（早已推广使用）。**传统 API 设计把每个 url 当作一个功能，Restful API 设计把每个 url 当作一个唯一的资源**。如何设计成一个资源：尽量不用 url 参数，用 method 表示操作类型。
- http headers：【1】request  headers -- Accept / Accept-Encoding / Accept-Language / Connection / Cookie / Host / User-Agent / Content-type；【2】response headers -- Content-type / Content-length / Content-Encoding / **Set-Cookie**。【3】缓存相关的 headers -- Cache-Control / Last-Modified / Etag。
- http 缓存：【1】什么是缓存：当浏览器向服务器请求资源的时候，都会率先抵达浏览器缓存，如果浏览器有这个资源请求的副本，就可以直接从浏览器获取资源，而不用去请求服务器；【2】为何需要缓存：为了提高网页打开速度，减少请求次数，降低服务器压力；可以被缓存的静态资源 js css img；【3】缓存策略：强制缓存、协商缓存；【4】强制缓存：**Cache-Control** -- max-age / no-cache，在 response headers 中，代替比较老的 Expires；【5】协商缓存：服务器端缓存策略，服务器判断客户端资源是否和服务端资源一样，一致则返回 304 否则返回 200 和新资源。请求和响应的时候带着**资源标识**，在 response headers 中，有两种 Last-Modified、Etag（优先使用）。
- 刷新页面对 http 缓存的影响：【1】正常操作 -- 地址栏输入 url / 跳转链接 / 前进后退：强制缓存有效，协商缓存有效；【2】手动刷新 -- F5 / 点击刷新按钮：强制缓存失效，协商缓存有效；【3】强制刷新 -- ctrl + F5：强制缓存失效，协商缓存失效。





